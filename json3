_Define(function(global) {
    "use strict";
    var Utils = global.Utils;
    //Learnt from antlr: visitors and listeners
    /**
     * @typedef Node {start:number,end?:number,text?:string,type:string}
     */
    /**@constructor*/
    var TreeListener = function() {
        this.ctx = [{
            children: []
        }];
    };
    /** @returns {Node}*/
    TreeListener.prototype.getContext = function() {
        return this.ctx[this.ctx.length - 1];
    };
    TreeListener.prototype.exit = function(key, pos, json) {
        var node = this.ctx.pop();
        node.end = pos;
        node.text = json.slice(node.start, node.end);
        this.onParse(node);
    };
    TreeListener.prototype.enter = function(key, pos) {
        var last = this.getContext();
        var node = {
            type: key,
            start: pos,
            children: []
        };
        last && last.children.push(node);
        this.ctx.push(node);
    };
    TreeListener.prototype.token = function(key, pos, json, value) {
        var last = this.getContext();
        var node = {
            type: key,
            start: pos,
            end: pos + value.length,
            text: value
        };
        last && last.children.push(node);
        this.onParse(node);
    };

    function AbstractParser() {
        this.walk = function(listener) {
            if (listener)
                this.listener = listener;
            try {
                this.resume();
            } catch (err) {
                var e = err;
                var state = this.getState();
                if (typeof e == 'string')
                    e = new Error(e);
                var error = e.message.split("\n");
                var before = state.text.slice(Math.max(0, state.pos - 15), state.pos) + "[here]" +
                    state.text.slice(
                        state.pos, Math.min((state.text.indexOf("\n", state.pos + 1) + 1) || Infinity, state
                            .pos + 10));
                error[0] += " at position " + state.pos + "\n:->" + before;
                e.message = error.join("\n");
                throw e;
            }
        };
    }

    //Simple parser without lexer used by JsonExt and Schema
    /**@typedef rule {
     *  rules?: [rules] -terminal rules read before this rule
        ///Input - One of re or token
     *  (re|token)?: regex or single character
        ///Output One of select,enter or next
     *  select?: [rules] - choose between multiple rules, uses lookahead
     *  enter?: start a new context, automatically validates any lookahead,
     *  exit?: context to return to after enter once all rules have been consumed
     *  next?: read the next token immediately after this rule,
     *  maybe?: like next but does not fail if there is no match so implies stopLookAhead
        /// Flags
     *  stopLookAhead: Use with next|select to automatically validate current lookahead
     *  isLookAhead: check this rule but don't consume any tokens
     *}
     */

    /* Considered replacing keys with numbers for speed boost. 
        But that would make it non-extensible */
    function RuleParser(rules) {
        RuleParser.super(this);
        //should get rid of this
        if (Array.isArray(rules)) {
            this.rules = {};
            rules.forEach(function(e) {
                if (this.rules[e.name]) throw 'Duplicate rule: ' + e.name;
                if (!e.name) throw 'Rules must have a name';
                this.rules[e.name] = e;
            }, this);
        } else this.rules = rules;
        if (rules) this.parseRules(this.rules);
    }
    RuleParser.prototype.Rule = function(keys, p, i) {
        var e = this;
        e.name = i;
        e.rules = e.enter = e.exit = e.next = e.select = undefined;
        if (e.rules) e.rules = p.rules.map(keys);
        if (e.select) e.select = p.select.map(keys);
        if (e.next) e.next = keys(p.next);
        if (e.enter) e.enter = keys(p.enter);
        if (e.exit) e.exit = keys(p.exit);
        e.stopLookAhead = !!p.stopLookAhead;
        e.isLookAhead = !!p.isLookAhead;
        e.canOptimize = !!p.canOptimize;
    };
    RuleParser.prototype.compile = function() {
        var keys = function(e) {
            return keys[e];
        };
        Object.keys(this.rules).forEach(function(e, i) {
            keys[e] = i;
            keys[i] = e;
        });
        var rules = [];
        for (var i in this.rules) {
            rules[i] = this.Rule(keys, this.rules[i], i);
        }
        this.rules = rules;
        return keys;
    };
    RuleParser.prototype.parseRules = function(rules) {
        var oneRules = [];
        for (var i in rules) {
            var e = rules[i];
            if (i === 'null') throw 'Use of reserved name null';
            if (i === '') throw 'Use of reserved name ""';
            if (e.re && !e.re.source.endsWith("|([^])")) {
                e.re = new RegExp(e.re.source + "|([^])", "g");
                if (e.token)
                    throw 'Cannot use .re and .token in the same rule. Perharps you mean to use .isLookAhead';
            }
            if (e.maybe) {
                if (e.select) throw 'Error: multiple exit clauses ' + i;
                e.stopLookAhead = true;
                e.select = [e.maybe, null];
            }
            if (!(e.next || e.select) || e.stopLookAhead) {
                if (e.rules) {
                    if (e.rules.length == 1) {
                        oneRules.push(e);
                    } else e.canOptimize = false;
                } else e.canOptimize = true;
            } else e.canOptimize = false;
            //A rule that does not depend on any other rule,
            //ie it won't consume tokens unless successful 
            //with the tail optimization and oneRule, reduced lookaheads from 12k to 0
            if ((e.select && e.enter) || (e.select && e.next) || (e.next && e.enter))
                throw 'Error: multiple exit clauses ' + i;
        }
        oneRules.forEach(function(e) {
            e.canOptimize = rules[e.rules[0]] && rules[e.rules[0]].canOptimize;
        });
        rules['null'] = {
            canOptimize: true,
            stopLookAhead: true
        }; //exit clause
        return rules;
    };
    /*Insert in front of cursor. If advance, move cursor to front of inserted text.*/
    RuleParser.prototype.insertAfter = function(text, advance) {
        var str = this.stream;
        var pos = this.pos;
        this.stream = str.slice(0, pos) + text + str.slice(pos);
        if (advance) this.pos += text.length;
    };

    /*Insert text at index. Updates cursor if behind cursor */
    RuleParser.prototype.insert = function(text, index) {
        var str = this.stream;
        var pos = this.pos;
        this.stream = str.slice(0, index) + text + str.slice(index);
        if (pos >= index) {
            this.pos += text.length;
        }
    };
    /*Delete text of size : length at position index. Updates cursor if behind cursor*/
    RuleParser.prototype.delete = function(length, index) {
        var str = this.stream;
        var pos = this.pos;
        this.stream = str.slice(0, index) + str.slice(index + length);
        if (pos >= index) {
            if (pos <= index + length) this.pos = index;
            else this.pos -= length;
        }
    };

    RuleParser.prototype.setState = function(opts) {
        this.stream = opts.text;
        this.state = opts.state || 'start';
        this.pos = opts.pos || 0;
        this.stack = opts.stack ? opts.stack.slice(0) : [];
    };
    RuleParser.prototype.getState = function() {
        return {
            text: this.stream,
            pos: this.pos,
            stack: this.stack.slice(0),
            state: this.state
        };
    };
    RuleParser.prototype.inLookAhead = false;
    RuleParser.prototype.inList = false;
    RuleParser.prototype.numEmptyConsume = 0;
    RuleParser.prototype.consumed = 0;
    RuleParser.prototype.lookAheads = 0;
    RuleParser.prototype.triedConsume = 0;
    RuleParser.prototype._debug = true;
    //To use a lexer, add tracking info, etc
    //we would have to override this method 
    //and next,
    //however, currently an array of tokens works
    //with token rules
    RuleParser.prototype.consume = function(rule) {
        var text = "";
        if (this._debug) {
            if (this.inLookAhead) {
                this.lookAheadRules = this.lookAheadRules || [];
                if (this.lookAheadRules.indexOf(rule) < 0) {
                    this.lookAheadRules.push(rule);
                }
                this.lookAheads++;
            } else this.triedConsume++;
        }
        //single character
        if (rule.token) {
            if (rule.token !== this.stream[this.pos]) return false;
            text = rule.token;
        }
        //or regex
        else if (rule.re) {
            rule.re.lastIndex = this.pos;
            var match = rule.re.exec(this.stream);

            if (match[match.length - 1] !== undefined) {
                return false;
            }
            text = match[0];
        }
        if (this._debug) {
            if (text) this.numEmptyConsume = 0;
            else if (++this.numEmptyConsume > 100) {
                throw new Error('Maximum number of empty tokens consumed');
            }
            this.consumed++;
        }
        return text;
    };

    //Try to consume one of multiple rules
    //Not optimal by default, tests paths twice, once in a
    //lookAhead and once again to notify listeners

    RuleParser.prototype.consumeSelect = function(rule) {
        var pos = this.pos;
        var wasInLookAhead = this.inLookAhead;
        var last = rule.select.length - 1;
        var name = this.state;
        for (var s = 0; s < rule.select.length; s++) {
            this.state = rule.select[s];
            this.inLookAhead = !(!wasInLookAhead && (s == last || this.rules[this.state].canOptimize));
            this.pos = pos;
            //lookahead
            if (this.consumeRules()) {
                if (this.inLookAhead && !wasInLookAhead) {
                    this.inLookAhead = false;
                    this.state = rule.select[s];
                    this.pos = pos;
                    //Found solution but must go through
                    //all rules again to notify the listener
                    return this.consumeRules();
                } else return true; //end of context
            }
        }
        //for debugging
        if (this.pos - pos < 10) {
            this.pos = pos;
            this.state = name;
        }
        return false;
    };
    RuleParser.prototype.consumeRules = function() {
        var rule = this.rules[this.state];
        console.log(this.state,this.pos);
        if (!rule) throw new Error('Unknown rule ' + this.state);
        //consume pre rules one by one
        if (rule.rules) {
            var wasInList = this.inList;
            this.inList = this.state;
            for (var i = 0; i < rule.rules.length; i++) {
                var e = rule.rules[i];
                this.state = e;
                if (!this.consumeRules()) {
                    this.inList = wasInList;
                    return false;
                }
            }
            //saving state after a rules list
            //gives wrong state ie null state
            this.state = this.inList;
            this.inList = wasInList;
        }

        //consume single tokens
        var result = this.consume(rule);
        if (result === false) return false;
        if (result && !this.inLookAhead && !rule.isLookAhead) {
            var pos = this.pos;
            this.pos += result.length;
            this.listener.token && this.listener.token(this.state, pos, this.stream, result);
        }


        if (this.inLookAhead && rule.stopLookAhead) return true;
        //Start a new context, also notifies select as successful
        if (rule.enter !== undefined) {
            if (this.inList) throw new Error('Bad state, cannot use enter rule for ' + this.state +
                ' while in executing rules in ' + this.inList);
            //can't enter context while in select so enter implies stop select
            if (this.inLookAhead) return true;
            this.stack.push(this.state);
            this.state = rule.enter;
            this.listener.enter && this.listener.enter(this.state, this.pos, this.stream);
            return this.consumeRules();
        } else if (rule.next !== undefined) {
            this.state = rule.next;
            return this.consumeRules();
        } else if (rule.select)
            return this.consumeSelect(rule);
        this.state = null;
        //end of context
        return true;
    };
    //override this method for better error recovery if u need that
    RuleParser.prototype.resume = function() {
        while (this.consumeRules()) {
            console.log('dmd');
            if (this.state == null) {
                while (this.stack.length) {
                    var rule = this.rules[this.stack.pop()];
                    this.listener.exit && this.listener.exit(rule.enter, this.pos, this.stream);
                    if (rule.exit) {
                        this.state = rule.exit;
                        break;
                    }
                }
                if (this.state == null) {
                    if (this.pos == this.stream.length) {
                        if (this._debug) console.log(Object.assign({}, this, {
                            stream: null
                        }));
                        return; //end of file
                    } else
                        throw 'Unexpected characters at end of file';
                } else continue;
            }
            if (this.pos >= this.stream.length) {
                break;
            }
        }
        var got = this.pos >= this.stream.length ? 'eof' : this.stream[this.pos];
        var expected = this.rules[this.state];
        expected = (expected.select ? 'one of ' + expected.select.map(function(e) {
            return this.rules[e].name || e;
        }).join(" , ") : (expected.name || this.state));
        throw 'Unexpected token <' + got + '>. Expected ' + expected;
    };
    Utils.inherits(RuleParser, AbstractParser);


    //Reimplemented using rule parser
    function JSONParser(str) {
        this.setState({
            text: str,
            state: 'JSON'
        });
    }
    JSONParser.prototype = new RuleParser(
        [{
                name: 'JSON',
                rules: ['whitespace'],
                enter: 'ROOT_VALUE',
                exit: 'whitespace'
            },
            {
                name: 'ROOT_VALUE',
                next: 'value'
            },
            {
                name: 'OBJ_VALUE',
                next: 'value'
            },
            {
                name: 'ARR_VALUE',
                next: 'value'
            },
            {
                name: 'value',
                select: ['string', 'number', 'boolean', 'nullval', 'l{', 'l[']
            },
            {
                name: 'string',
                re: /\"(?:[^\n\\\"]|\\.)*\"|^\'(?:[^\n\\\']|\\.)*\'/
            },
            {
                name: 'nullval',
                re: /null/
            },
            {
                name: 'number',
                re: /\d+(?:\.\d*)?/
            },
            {
                name: 'identifier',
                re: /[a-zA-z_$][a-zA-Z_$0-9]*/
            },
            {
                name: 'boolean',
                re: /(?:true|false)/
            },
            {
                name: 'l{',
                token: '{',
                //add look ahead so that brace is part of next context
                isLookAhead: true,
                enter: 'OBJECT',
            },
            {
                name: 'l[',
                token: '[',
                isLookAhead: true,
                enter: 'ARRAY'
            },
            {
                name: 'whitespace',
                re: /\s*/
            },
            {
                name: 'OBJECT',
                rules: ['{', 'whitespace'],
                select: ['}', 'item']
            },
            {
                name: 'KEY',
                select: ["string", "identifier"]
            },
            {
                name: 'item',
                enter: 'KEY',
                exit: 'colon'
            },
            {
                name: 'colon',
                rules: ["whitespace", ":", "whitespace"],
                enter: 'OBJ_VALUE',
                exit: 'end_item'
            },
            {
                name: 'end_item',
                rules: ["whitespace"],
                select: ["}", "obj_sep"]
            },
            {
                name: "obj_sep",
                rules: [",", "whitespace"],
                select: ["}", "item"]
            }, {
                name: 'ARRAY',
                rules: ["[", "whitespace"],
                select: ["]", 'arr_item']
            },
            {
                name: 'arr_item',
                enter: 'ARR_VALUE',
                exit: 'close_arr_item'
            },
            {
                name: 'close_arr_item',
                rules: ["whitespace"],
                select: ["]", "arr_sep"],
            },
            {
                name: 'arr_sep',
                rules: [",", "whitespace"],
                select: ["]", "arr_item"]
            },
            {
                name: "]",
                token: "]"
            }, {
                name: "[",
                token: "["
            }, {
                name: "{",
                token: "{"
            },
            {
                name: "}",
                token: "}"
            },
            {
                name: ':',
                token: ':'
            },
            {
                name: ",",
                token: ","
            }
        ]);
    JSONParser.prototype._debug = false;
    global.JSONParser = JSONParser;
    global.TreeListener = TreeListener;
    global.RuleParser = RuleParser;
});
_Define(function(global) {
    var JSONParser = global.JSONParser;
    var TreeListener = global.TreeListener;
    var Utils = global.Utils;
    var repeat = Utils.repeat;

    var JSONExt = new JSONParser();
    JSONExt.rules = Object.assign({}, JSONParser.prototype.rules, JSONExt.parseRules({
        "lax_start": {
            name: "lax_start",
            rules: ["not_json"],
            "enter": "JSON",
            "exit": "lax_end"
        },
        "not_json": {
            name: 'not_json',
            re: /[^\{]*/,
        },
        "lax_end": {
            re: /[^]*/
        },
        "whitespace": {
            name: "whitespace",
            rules: ["spaces"],
            maybe: "comment",
        },
        "spaces": JSONParser.prototype.rules.whitespace,
        "comment": {
            name: 'comment',
            re: /\/\/[^\n]*|\/\*(?:[^\*]|\*[^\/])*\*\//,
            maybe: "whitespace"
        }
    }));
    var keys = JSONExt.compile(),
        IDENTIFIER = keys.IDENTIFIER,
        ARRAY = keys.ARRAY,
        COMMENT = keys.COMMENT,
        LAX_END = keys.LAX_END,
        NOT_JSON = keys.NOT_JSON,
        OBJECT = keys.OBJECT,
        STRING = keys.STRING;
    /*Add comments to files*/
    JSONExt.addComments = function(str, getInfo) {
        var walker = new JSONParser(str);

        /**@type {Array<{type:string,pos:number,indent:string,name?:string}>}*/
        var ctx = [];

        var next = "",
            nextPos = -1,
            key;

        function postComment(fullName, pos) {
            var info = getInfo(fullName);
            if (!info) return;
            var comments = info.split("\n").filter(Boolean);
            if (comments.length > 1) {
                var lines = [];
                for (var j in comments) {
                    lines.push(key.indent + (j == 0 ? "/* " : " * ") + comments[j]);
                }
                lines.push(key.indent + " */\n");
                next = "\n" + lines.join("\n");
            } else next = "\n" + key.indent + "/* " + comments[0] + " */\n";
            nextPos = pos;

        }
        var isFirst = false;
        //listener pattern
        try {
            walker.walk({
                enter: function(tag, pos, str) {
                    switch (tag) {
                        case "KEY":
                        case "ARR_VALUE":
                            if (isFirst) {
                                //"key": ^{
                                // comment
                                isFirst = false;
                                var newline = str.lastIndexOf("\n", pos);
                                if (newline >= nextPos) {
                                    key = ctx[ctx.length - 1];
                                    walker.insert(next.slice(0, -1), newline);
                                    key.handled = true;
                                }
                                next = "";
                            }
                            if (tag == 'ARR_VALUE') break;
                            //^"ke...
                            //start a key
                            var indent = str.lastIndexOf("\n", pos) + 1;
                            ctx.push({
                                type: "key",
                                pos: pos,
                                indent: repeat(pos - indent),
                            });
                            break;
                        case "ARRAY":
                        case "OBJECT":
                            //"key": ^{
                            if (!ctx.length) return;
                            var fullName = ctx.map(function(e) {
                                return e.name;
                            }).join(".");
                            key = ctx[ctx.length - 1];
                            //TODO proper indenting
                            postComment(fullName, pos);
                            if (next)
                                isFirst = true;
                            break;
                    }
                },
                exit: function(tag, pos, text) {
                    switch (tag) {
                        case "KEY":
                            //"key"^
                            //get key name
                            key = ctx[ctx.length - 1];
                            key.name = text.slice(key.pos + 1, pos - 1);
                            return;
                        case "OBJECT":
                        case "ARRAY":
                            isFirst = false;
                            break;
                        case "OBJ_VALUE":
                            //"key": "value"^
                            //get the value of the key to insert after , { or [
                            //or before ] } hopefully all possible tokens
                            if (!ctx.length) return;
                            var fullName = ctx.map(function(e) {
                                return e.name;
                            }).join(".");
                            key = ctx.pop();
                            if (key.handled) return;
                            postComment(fullName, pos);
                    }
                },
                token: function(type, pos, text, token) {
                    if (!next || isFirst) return;
                    switch (token) {
                        case "]":
                        case "}":
                            //try to insert it before token
                            var before = text.lastIndexOf("\n", pos);
                            if (before >= nextPos) {
                                //"key":"value"
                                //comment
                                //}
                                walker.insert(next.slice(0, -1), before);
                            } else {
                                //"key":"value"}
                                //comment
                                walker.insertAfter(next, true);
                            }
                            next = "";
                            break;
                        case ",":
                            //"key": "value",
                            //comment
                            //insert comment before next item
                            walker.insertAfter(next, true);
                            next = "";
                    }
                }
            });
        } catch (e) {
            console.error(e);
        }
        return walker.getState().text;
    };

    /*Parse files with json5 syntax*/
    JSONExt.parse = function(json, reviver, strict) {
        var hasComments = json.indexOf("//") > -1 || json.indexoF("/*") > -1;
        var trailingCommas = /,\s*[}\]]/.test(json);
        var wierdStrings = /\'|[^"\s]\s*:/.test(json);
        if (strict === false || hasComments || trailingCommas || wierdStrings) {
            var walker = this;
            this.setState({
                state: strict === false ? 'lax_start' : 'JSON',
                text: json
            });
            var visitor = new TreeListener();
            //do we really need to construct this every time
            visitor.onParse = function(node) {
                //we have to be careful not to mess up any position info
                switch (node.type) {
                    case IDENTIFIER:
                        walker.insert('"', node.end);
                        walker.insert('"', node.start);
                        break;
                    case STRING:
                        if (node.text[0] == "\'") {
                            walker.delete(node.end - node.start, node.start);
                            var text = node.text.slice(1, -1).replace(/\"/g, "\\\"");
                            walker.insert('\"' + text + '\"', node.start);
                        }
                        break;
                    case OBJECT:
                    case ARRAY:
                        if (trailingCommas)
                            for (var i = node.children.length; i-- > 0;) {
                                var child = node.children[i];
                                if (child.type == ",") {
                                    walker.delete(1, node.start);
                                    walker.insert(" ", node.start);
                                } else if (child.children) break;
                            }
                        break;
                    case COMMENT:
                    case NOT_JSON:
                    case LAX_END:
                        walker.delete(node.text.length, node.start);
                        walker.insert(repeat(node.text.length), node.start);
                }
            };
            console.time('walk');
            walker.walk(visitor);
            console.timeEnd('walk');
            json = walker.getState().text;
        }
        console.time('parser');
        var t = JSON.parse(json, reviver);
        console.timeEnd('parser');
        return t;
    };
    global.JSONExt = JSONExt;
});