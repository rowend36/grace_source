//Generated by grace/ext/dev/dts_gen
//And further hand tuning.
//Most of the todos are from closure classes
//Ace classes
/// <reference path="./ace.d.ts" />
/// <reference path="./modules.d.ts" />
declare interface Editor extends Ace.Editor{}
declare interface EditSession extends Ace.EditSession{}
declare interface AceDocument extends Ace.Document{}
declare interface UndoManager extends Ace.UndoManager{}
declare interface TextInput{
 getElement():HTMLElement
 focus():void
}
declare const Env: Any
declare namespace Ace{
 interface Completer{
  name: string
 }
 interface UndoManager{
  $undoStack: Array < Any > ;
  $redoStack: Array < Any > ;
  $maxRev: number;
  $syncRev(): void
  $redoStackBaseRev: number;
 }
 interface Editor{
  container: HTMLElement
  textInput: TextInput
  exitMultiSelectMode(): void
  getMainCompleter(): BaseClient|null
  [option:string]: number|string|boolean|falsy
 }
 type UndoFilter = number | ((deltas:Delta)=>boolean) | Array<Delta>
 interface EditSession{
  partialUndo(args?: UndoFilter|falsy,splitDeltas?:boolean): void
  partialRedo(args?: UndoFilter|falsy,splitDeltas?:boolean): void
 }
}
type HashHandler = Any;
declare function $(el:string|$Element|Element|EventTarget|null, context?: HTMLElement):$Element
//Cashdom
declare interface $Element{
 on(...args):$Element
 off(...args):$Element
 once(...args):$Element
 click(...args):$Element
 [key:number]:HTMLElement
 [key:string]:any
} //TODO
declare interface ErrnoException{
 code: number,
 message: string
}
declare namespace FS {
 export interface Stats{
  
 }
}
declare type NodeBuffer = Uint8Array;
declare interface FS {
 createReadableStream(path: string): ReadStream;
 createWritableStream(path: string): WriteStream;
 lstat(path: string, callback?: (err: ErrnoException, stats: FS.Stats) => void): void;
 mkdir(path: string, callback?: (err?: ErrnoException) => void): void;
 readdir(path: string, callback?: (err: ErrnoException, files: string[]) => void): void;
 readFile(filename: string, callback: (err: ErrnoException, data: NodeBuffer) => void): void;
 readFile(filename: string, encoding: string|null, callback: (err: ErrnoException, data: any) => void): void;
 readFile(filename: string, options: { encoding?: string; }, callback: (err: ErrnoException, data: any) => void): void;
 readlink(path: string, callback?: (err: ErrnoException, linkString: string) => any): void;
 rename(oldPath: string, newPath: string, callback?: (err?: ErrnoException) => void): void;
 rmdir(path: string, callback?: (err?: ErrnoException) => void): void;
 stat(path: string, callback?: (err: ErrnoException, stats: FS.Stats) => any): void;
 symlink(srcpath: string, dstpath: string,  callback?: (err?: ErrnoException) => void): void;
 unlink(path: string, callback?: (err?: ErrnoException) => void): void;
 writeFile(filename: string, data: any, callback?: (err: ErrnoException) => void): void;
 writeFile(filename: string, data: any, encoding: string|null, callback?: (err: ErrnoException) => void): void;
 writeFile(filename: string, data: any, options: { encoding?: string}, callback?: (err: ErrnoException) => void): void;
} //TODO
declare interface Any{
 [key: string]: any
 //placeholder for unknown objects
 //since any allows null and undefined
}
declare type falsy = undefined|false|null|0
declare type Callback<T=any> = (err:Error|undefined,res:T)=>void
declare interface ReadStream {
 close(): void
 read(cb: Callback<NodeBuffer|null>):void
}
declare interface WriteStream {
 close(): void
 write(data: NodeBuffer,cb: Callback):void
}
declare type ActionHostId = 
 "editor"|"actionbar"|"actionbar.more"|"fileview"|"fileview.header"|"fileview.project"|"fileview.file"|"fileview.folder"|string
/** A superset of ace editor commands interface */
declare interface Action {
 id: string //Must not be provided
 name: string // Used as the command name
 caption: string // Used for the menu item
 description: string // Shown in command list
 icon: string // Material icon shown in toolbar 
 info: string // Documentation about the command
 bindKey: string | {
  windows: string,
  mac: string
 }
 exec(editor: Editor, args? : (object | ActionEvent)): void
 handle(event: ActionEvent): void
 ["!update"](self: Any, update: (id: string, data: Action | null) => void): void
 showIn? : Array<ActionHostId>|null
 context? : string,
 readOnly: boolean,
 dontClose: boolean, //Action should not dismiss the dropdown
 command?: string
 hasChild?: boolean
 isAvailable(editor: Editor): boolean
 priority: number
 sortIndex: number
 subIcon: string
 subTree: Record<string,Action>
 extension? : string // Used to filter in fileviews,
 filename? : string // Used to filter in fileviews,
 multiSelectAction: "forEach" | "forEachLine" | Function | undefined,
 scrollIntoView: true | "cursor" | "center" | "selectionPart"
 // aceCommandGroup: "fileJump",
}
declare interface ActionEvent {
 filename: string,
 filepath: string,
 fs: FS,
 rootDir: string,
 fileview? : FileBrowser,
 editor? : Editor,
 element? : HTMLElement // Clicked list item
 anchor? : HTMLElement // Current anchor of the dropdown
 event? : Event,
 marked? : [string],
}
declare interface Schema {
 isOptional? : boolean
 name?: string
 validate(value: any): falsy | string
}
declare interface Closeable{
  id: string
  close()
 }
declare interface Event{
 stopPropagation(): void
 preventDefault(): void
}
declare interface AsyncEvent{
 await(token: any,cb:Function): void
 isDelayed: boolean
 repeat(): void
}
 
declare type EventsEmitter = import('core/events_emitter').EventsEmitter
declare type Doc = import('docs/document').Doc
declare type FileBrowser = typeof import('ext/fileview/file_browser').FileBrowser;
declare type View = import('ui/view').View;
declare type BaseClient = import('ext/language/base_client').BaseClient;
declare type BaseProvider = import('ext/language/base_provider').BaseProvider;
declare module "core/actions" {
 const exports: {
  Actions: typeof exports
  addAction(action: Any) : void
  addActions(actions: Any , defaults?: Any|undefined) : void
  checkContext(context: any) : any
  createEvent(editor: any) : Any
  registerActionHost(name: string , handler: Function) : void
 }
 export = exports
}
declare module "core/ajax" {
 const exports: {
  ajax(url: string , opts: Any) : Promise<any>
  from(module: any) : Function
 }
 export = exports
}
declare module "core/app_events" {
 const exports: {
  AppEvents: EventsEmitter & {
   checkEvents: boolean
   pause() : any
   paused: boolean
   resume() : any
  }
 }
 export = exports
}
declare module "core/base_fs" {
 export abstract class BaseFs implements FS {
  getDisk(): string
  getRoot(): string
  isEncoding(e: any): string
  openReadableStream(path: any): ReadStream
  openWritableStream(path: any): WriteStream
  readlink(path: any, callback: any): void
  symlink(path: any, dest: any, callback: any): void
 }

 const exports: {
  BaseFs : typeof BaseFs
 }
 export default exports
}
declare module "core/channels" {
 export const Channels: {
  channelHasPending(id: string): void
  ownChannel(channel: string, owner: Function): void
  postChannel(channel: string, arg1?: any, arg2?: any, arg3?: any, arg4?: any): void
 }
 const exports: {
  Channels: typeof Channels
 }
 export default exports;
}
declare module "core/config" {
 const exports: {
  Config: EventsEmitter & {
   allConfigs: Any
   configure(key: string , value: any , ns?: string , fireEvents?: boolean|falsy) : boolean
   configureObj(key: string , obj: Array<any>|Any , ns: string , fireEvents: boolean) : boolean
   forPath(resource: any , ns: any , key: any) : any
   frozen: boolean
   getConfigInfo(i: string) : Any
   getObj(key: string , def?: Any|undefined) : Any
   putObj(key: string , obj: Any) : void
   register(name: string , ns?: string|undefined , defaultValue?: boolean|undefined) : string|boolean|undefined
   registerAll<T>(configs?: T , ns?: string|undefined) : T extends falsy?Any:T & Any;
   registerInfo(info: Any|string , ns?: string|undefined) : void
   registerObj(name: string , ns: string , defaultValue?: Any|undefined) : Any
   setHandler(ns: string , handler: Any) : void
   unregister(name: any , ns: any) : void
   withoutStorage(func: Function , _v?: Any|undefined , _p?: string|undefined , _m?: Any|undefined) : boolean
  }
  storage: Storage
 }
 export = exports
}
declare module "core/depend" {
 const exports: {
  after(init: Function , subsequent?: Function|undefined) : Function
  promise(init: any) : ()=>Promise<any>
  syncRequire(deps: Array<string> , cb: Function) : any
 }
 export = exports
}
declare module "core/events_emitter" {
 export class EventsEmitter {
  _debug: boolean
  _eventQueue: any
  asyncTrigger<T>(eventName: string, props?: T, onTasksHandled?: Function): T & Event & AsyncEvent
  checkEvents: boolean
  createEvent(props: Any | undefined): Event
  debug(): void
  off(event: string, func: Function): void
  on(event: string, func: Function, capture?: boolean ): void
  once(event: string, func: Function, capture?: any): Function
  signal<T>(eventName: string, obj?: T, addEventProps?: falsy ): T
  signal<T>(eventName: string, obj: T, addEventProps: true): T
  & Event
  trigger<T>(eventName: string, obj?: T, noEventProps?: true ): T & Event
  trigger<T>(eventName: string, obj: T, noEventProps: false ): T
  triggerForever(eventName: string): void
 }

 const exports : {
  EventsEmitter: typeof EventsEmitter
 }
 export default exports
}
declare module "core/file_servers" {
 export const FileServers: {
  $getDefaultServer(): Any
  $loadServers(): void
  $serverFactories: {
   [type: string]: {
    caption: string
    config: any
    create(): FS
   }
  }
  availableEncodings(server: Any): Array <string>
  copyFile(path: string, newpath: string, server: FS | falsy, newserver: FS|falsy,
   cb: Function): void
  createError(obj: Any): Error
  createServer(type: string, params: Any, id: string | falsy): FS
  createStats(stat: any): any
  deleteServer(id: any): void
  detectEncoding(path: string, server: FS, cb?: Function): string
  getFileServer(id?: string | falsy, fallback?: boolean): FS
  moveFile(path: any, newpath: any, server: FS | falsy, newserver: FS | falsy, cb: Function): any
  normalizeEncoding(enc: any): any
  openIntent(intent: any): void
  registerFileServer(type: string, caption: string, factory: Function, config: Array <unknown> | undefined,
   isDefault: boolean | undefined): void
  replaceServer(stub: FS, server: FS): void
 }
 export const EncodingToNames: {
  [encoding: string]: string
 }
 const exports: {
  EncodingToNames: typeof EncodingToNames
  FileServers: typeof FileServers
 }
 export default exports
}
declare module "core/file_utils" {
 type Tester = {
  test(text:string):boolean
 }
 const exports: {
  FileUtils: {
   addToRecents(folder: string) : void
   fileBookmarks: Array<string>
   getBookmarks() : Array<string>
   getDoc(path: string , server: FS , callback: Function , factory: any) : void
   getDocFromEvent(ev: Any , callback: Function , forceNew: boolean , justText: boolean) : void
   isBinaryFile(name: string) : void
   isBuffer(buf: any) : any
   openDoc(path: string , server: FS , callback: any , factory: any) : void
   readFile(path: string , server: FS , cb: Function) : void
   setBookmarks(bookmarks: any) : void
   sort(files: Array<string> , mode: string , custom: any) : Array<string>
   //Only Available on appLoaded
   genQuickFilter(s: any) : Tester
   globToRegex(s: any) : Tester
   globToWalkParams(glob: any) : {
      root: string //the root directory that contains all the matches
      canMatch: Tester, //matches directories that could contain possible matches
      matches: Tester, //matches files that match the glob
   }
  } & 
  typeof import('core/channels').Channels & 
  typeof import('core/path').path & 
  typeof import('core/file_servers').FileServers & 
  typeof import('core/register_fs_extension') &
  typeof import('core/project_manager').ProjectManager &
  typeof import('ext/file_utils/walk')
 }
 export = exports
}
declare module "core/jquery_compat" {}
declare module "core/parser" {
 class TreeListener {
  enter(key: string|number , pos: number) : void
  exit(key: string|number , pos: number , json: string) : void
  getContext() : Any
  token(key: string|number , pos: number , json: string , value: string) : void
 }
 export abstract class AbstractParser {
  walk()
  getError()
  pos: number
  stack: Array<string>
  state: string
  stream: any
  inList: boolean
  inLookAhead: boolean
  errorState: number
  lookAheads: number
  numEmptyConsume: number
  _debug: boolean
  triedToConsume: number
  abstract consumeFully(): number|undefined
 }
 export namespace RuleParser {
  export interface Rule{
   
  }
  export class Rule implements Rule{
   name: string
  }
 }
 export class RuleParser extends AbstractParser {
  static super(): any
  constructor(rules?: Any )
  Rule: typeof RuleParser.Rule
  compile(): Any
  consume(rule: Any): string | boolean | undefined
  consumeFully(): number | undefined
  consumeRules(): boolean
  consumeSelect(rule: Any): boolean
  consumed: number
  delete(length: number, index: number): void
  getState(): Any
  insert(text: string, index: number): void
  insertAfter(text: string, advance: boolean): void
  lintRule(i: string, rule: Any): void
  parseRules(rules: Any): Any
  setState(opts: Any): void
  
 }

 const exports: {
  RuleParser : typeof RuleParser
  TreeListener : typeof TreeListener
 }
 export default exports
}
declare module "core/path" {
 export const path: {
  dirname(path: string): string
  extname(name: string): string
  filename(e: string): string
  isDirectory(name: string): boolean
  join(base: string,...others:string[]): string
  normalize(path: string): string
  relative(from: any, path: string, forceKeepSlash: any, noBackTrace: any): string | null
  removeTrailingSlash(e: string): string
  resolve(from: string, path: string): string
  sep: string
 }
 const exports: {
  path: typeof path
 }
 export default exports
}
declare module "core/project_manager" {
 export namespace ProjectManager{
   export const NO_PROJECT: string
   export function getConfig(name: any , cb: Function , _project: any): any
   export function getProject(): Any
   export function openProject(path: string , fileServer: FS , name: string): void
   export function saveConfig(name: any , content: any , cb: Function , project: any) : void
 }
 const exports: {
  ProjectManager: typeof ProjectManager
 }
 export default exports
}
declare module "core/recovery" {
 const exports: {
  Recovery: {
   breakpoint(id: string , handle: any , timeout: number) : number
   clearData(id: any , namespace: any) : Function
   defaultHandler(id: any , stack: any) : void
   fail(error: any , message: any) : void
   hasFailures(id: string|number) : boolean
   removeBreakpoint(id: string) : void
   setBreakpoint(id: string , handle?: Function|undefined) : void
  }
 }
 export = exports
}
declare module "core/ref_counted" {
 export class RefCounted {
  destroy() : void
  hasRef(id: string) : boolean
  ref(id: string) : void
  unref(id: string) : void
 }
 const exports: {
  RefCounted : typeof RefCounted
 }
 export default exports
}
declare module "core/register_fs_extension" {
 import {BaseFs} from 'core/base_fs'
 class StubFileServer extends BaseFs {
  static super(): any
  constructor(resolve: Function)
  $isStub: boolean
  load(): void
 }
 const exports: {
  StubFileServer: typeof StubFileServer
  registerFsExtension(id: string , caption: string , factory: Function , config: Array<unknown>) : void
 }
 export = exports
}
declare module "core/registry" {
 export class Provider {
  addName(alias: any): void
  modes: Array <unknown>
  name: string
  names: any
  priority: number
}

 export class Registry {} //TODO
 const exports: {
  Provider : typeof Provider
  Registry : typeof Registry
 }
 export default exports
}
declare module "core/schema" {
 class XArray implements Schema{
  name: string
  validate(value: any) : falsy|string
 }
 class XEnum implements Schema{
  constructor(values:Array<any>)
  name: string
  validate(value: any) : falsy|string
 }
 class XMap extends XObject implements Schema{
  static super() : any
  constructor(keys: Schema , values: Schema)
  name: string
  validate(value: any) : falsy|string
 }
 class XNot implements Schema{
  constructor(schema: Schema)
  name: string
  validate(value: any) : falsy|string
 }
 class XObject implements Schema{
  constructor(schema: Record<any,Schema>)
  name: string
  validate(value: any) : falsy|string
 }
 class XOneOf implements Schema{
  constructor(schemas:Array<Schema>)
  name: string
  validate(value: string) : string|falsy
 }
 class XOptional implements Schema{
  constructor(schema:Schema)
  isOptional: boolean
  name: string
  validate(value: any) : any
 }
 class XRegex extends XValidIf implements Schema{
  static super() : any
  constructor(regex: RegExp , name: any)
  name: string
  validate(value: any) : falsy|string
 
 }
 class XValidIf implements Schema{
  constructor(test:(value: any)=>boolean|falsy)
  name: string
  validate(value: any) : falsy|string
 }
 const exports: {
  Schema: {
   Any: {
    name: string
    validate() : void
   }
   IsBoolean: XValidIf
   IsFilename: XRegex
   IsKey: XValidIf
   IsMode: XValidIf
   IsNull: XValidIf
   IsNumber: XValidIf
   IsObject: XObject
   IsPlain: XValidIf
   IsSize: XOneOf
   IsString: XValidIf
   IsTime: XOneOf
   IsUrl: Schema
   NotNull: XValidIf
   XArray : typeof XArray
   XEnum : typeof XEnum
   XMap : typeof XMap
   XNot : typeof XNot
   XObject : typeof XObject
   XOneOf : typeof XOneOf
   XOptional : typeof XOptional
   XRegex : typeof XRegex
   XValidIf : typeof XValidIf
   fromValue(value: any) : Schema
   parse(value: string|Any) : Schema
  }
 }
 export = exports
}
declare module "core/store" {
 export class Store<T> {
  constructor(id: string, _default?: T)
  $onChange(data: T): void
  destroy(): void
  get(): T
  onChange(): void
  save(): void
  set(data: T): void
 }

 const exports: {
  Store : typeof Store
 }
 export default exports
}
declare module "core/utils" {
 type DelayedFunction<T> = T & {
  cancel(): void
  now: T
  later(wait?:number): void
 }
 const exports: {
  Utils: {
   asyncForEach<T>(
    list: Array<T>,
    each: (
     e:T,
     i:number,
     next:Function
    )=>void,
    finish?: Function|falsy ,
    parallel?: number|falsy ,
    unfinished?: falsy,
    cancellable?: falsy
   ) :void
   asyncForEach<T>(
    list: Array<T>,
    each: (
     e:T,
     i:number,
     next:Function
    )=>void,
    finish: Function|falsy ,
    parallel: number|falsy ,
    unfinished: true|1,
    cancellable?: falsy
   ) :Function
   asyncForEach<T>(
    list: Array<T>,
    each: (
     e:T,
     i:number,
     next:Function,
     cancel:Function
    )=>void,
    finish: Function|falsy ,
    parallel: number|falsy ,
    unfinished: falsy,
    cancellable: true|1
   ) :void
   asyncForEach<T>(
    list: Array<T>,
    each: (
     e:T,
     i:number,
     next:Function,
     cancel:Function
    )=>void,
    finish: Function|falsy ,
    parallel: number|falsy ,
    unfinished: true|1,
    cancellable: true|1
   ) :Function
 
   assert(cond: Any|boolean , e: string) : boolean
   createCounter(cb: Function) : Any
   debounce<T extends Function>(func: T , wait?: number|undefined) : DelayedFunction<T>
   delay<T extends Function>(func: T , wait?: number) : DelayedFunction<T>
   genID(prefix: string) : string
   getCreationDate(id: string) : Date
   groupEvents(_emitter?: EventsEmitter|undefined) : Any|undefined
   htmlEncode(string: string) : string
   inherits(prop: Function , superClass: Function , mixins?: Function) : void
   mergeList(original: Array<unknown> , update: Array<unknown> , copy: any , compare: any) : Array<unknown>
   noop(...args: any[]) : void
   not(func: any) : Function
   notIn(arr: Array<unknown>) : ()=>boolean
   parseList(list_text: string) : Array<unknown>
   parseSize(text: string , validate?: any) : number
   parseTime(text: string , validate?: any) : number
   plural(no: number , name: string) : string
   regEscape(s: string) : string
   removeFrom(arr: Array<unknown> , item?: Any|string|undefined) : number
   repeat(amount: number , sep: any) : string
   sentenceCase(text: string) : string
   setImmediate(t: Function, ...args:any[]) : number
   setProp(obj: Any , prop: string , value: Any|string|boolean) : boolean|undefined
   smallCaps(text: any) : string
   spread<T extends Function>(func: Function , wait: number) : DelayedFunction<T>
   toChars(str: string) : string
   toDate(time: any) : string
   toSize(size: number , nameType?: "short"|"full") : string
   unimplemented() : void
   waterfall(steps: Array<unknown>) : void
  }
 }
 export = exports
}
declare module "docs/docs" {
 export function $dmpDiffToAceDeltas(diff: any , start_line: any , start_col: any) : Array<unknown>
 export const Docs: typeof import("docs/docs_base") & typeof import("docs/mixin_docs_blob") & typeof import("docs/mixin_docs_save") & typeof import("docs/mixin_docs_persist") & typeof import("docs/mixin_docs_tabs")
 export function closeDoc(docId: string , keepUndos?: any) : void
 export function openDoc(name: string|falsy , content/*:string|Doc*/: Doc|string , path?/*:string?*/: string|falsy , opts?: Any|undefined) : string
 
 const exports: {
  $dmpDiffToAceDeltas: typeof $dmpDiffToAceDeltas
  Docs: typeof Docs
  closeDoc: typeof closeDoc
  openDoc: typeof openDoc
 }
 export default exports
}
declare module "docs/docs_base" {
 const exports: {
   $autoSave() : void
   $defaults: {
    firstLineNumber: number
    foldStyle: string
    highlightMerge3: boolean
    indentedSoftWrap: boolean
    navigateWithinSoftTabs: boolean
    newLineMode: string
    overwrite: boolean
    tabSize: number
    useSoftTabs: boolean
    useWorker: boolean
    wrap: string
   }
   $delete(id: string) : void
   $dmpDiffToAceDeltas(diff: any , start_line: any , start_col: any) : Array<unknown>
   $set(id: string , doc: Doc) : void
   Docs: typeof exports
   forEach(cb: Function , ctx?: any) : void
   forPath(path: string , server?: Any|undefined) : Doc|undefined
   forSession(session: EditSession) : Doc|undefined
   generateDiff(from: string , value: string , start_line?: number , start_column?: number) : Array<Any>
   get(id: string) : Doc
   getName(id: string) : string|undefined
   has(id: string) : boolean
   ids() : any
   numDocs() : number
  }
 export = exports
}
declare module "docs/document" {
 export interface SavedState{
  content?: string,
  selection?: any,
  scrollTop: number,
  scrollLeft: number,
  history: {
   undo: Array<Any>
   redo: Array<Any>
   m: number,
   b?:number
  } | null,
  folds: Array<Any>
 }
 export interface Doc extends AceDocument /* mixins RefCounted */ {
  id: string
  orphan?:boolean
  options: Any
  session:  EditSession
  dirty: boolean
  $safe: boolean
  duplicateId?: number
  path: string|null
  saveRev: number
  _LSC: number
  $fromSerial?: boolean
  allowAutosave?: boolean
  editorOptions?: Any
  factory?: string
  clones?: Array<EditSession>
  $clearRevertStack(): void
  $loadCheckpoints(): any
  abortChanges(fromRevision?: any): any
  checkout(checkpoint: any, data: any, cb: Function): void
  clearHistory(): void
  cloneSession(exclusive: any): EditSession
  closeSession(session: EditSession): boolean
  createHistory(state?: Any ): UndoManager
  checkpoints: Array<{
   name:string
   time:number
   key:string
  }>,
  deleteCheckpoint(name: any): any
  destroy(): void
  encoding?: string
  fileServer?: string
  fork(orphan: any): Doc
  getChecksum(res?: string ): number
  getDeltas(start: number): Array <unknown>
  getEncoding(): string
  getFileServer(): Any
  getPath(): string | undefined
  getRevision(): number
  getSavePath(): string | undefined
  getSize(): number
  gotoCheckpoint(name: any, cb: Function): any
  hasRef(id: string): boolean
  isLastSavedValue(res: any): any
  isReadOnly(): any
  isTemp(): boolean
  onChange(): void
  redoChanges(): void
  ref(id: string): void
  refresh(callback: Function, ignoreDirty?: boolean, confirm?: boolean): void
  restoreState(state:  Partial<SavedState>, session?: EditSession): void
  restoreView(state: Partial<SavedState>, session?: EditSession ): void
  returnFromCheckpoint(cb: Function): any
  save(callback: any): void
  saveCheckpoint(name: any, isTemporary: any, cb: Function): any
  saveCheckpoint(name: any, cb: Function): any
  saveState(): SavedState
  serialize(): SavedState & Any
  setClean(rev: any, res: string): void
  setDirty(fromChange?: boolean ): void
  setEncoding(encoding: any): void
  setHistory(undoManager: UndoManager, session?: EditSession ): void
  setOption(name: string, value: any): void
  setPath(path?: string ): void
  setValue(e: string, isClean?: any): void
  syncMode(): void
  toggleAutosave(on: boolean): void
  unref(id: string): void
  unserialize(json: Partial<SavedState> & Any): void
  updateValue(res: string, isClean: any): void
}
export const Doc:{
  super(): any
  prototype: Doc
  new(content: string, path?: string , mode?: string , id?: string , orphan?: boolean): Doc
}
 const exports: {
  Doc : typeof Doc
 }
 export default exports
}
declare module "docs/document_commands" {
 const exports: {
  DocumentCommands: Array<unknown>
 }
 export = exports
}
declare module "docs/history_saver" {
 const exports: {
  $completeLoad(doc: Doc , res: string , currentRev: number) : boolean
  _debug: boolean
  canRecover(id: any) : any
  limits: {
   maxDocDataSize: number
   maxUndoHistory: number
  }
  load(doc: Doc , obj: Any) : void
  onRemoteChange(doc: any , obj: any) : boolean
  recover(id: any , doc: any) : void
  refresh(doc: any , res: any) : void
  save(doc: Doc , keepContent?: boolean) : false|string
  shrinkData(obj: Any) : string
 }
 export = exports
}
declare module "docs/mixin_docs_blob" {
 const exports: {
  $determineQuota(i?: any) : number
  $maxStoreSize() : number
  $routineCheck(prefix: string) : Array<string>
  allBlobs(id: string) : Array<string>
  cleanBlobs(force: boolean , maxSize: any) : void
  freeBlobSpace() : boolean
  getBlob(key: string) : string|Any
  getBlobInfo(key: string) : Any
  hasBlob(id: string , type?: string|undefined) : string|undefined
  loadBlob(key: string , cb?: Function|undefined) : string|undefined
  removeBlob(key: string) : boolean
  saveBlob(id: string , type: string , value: string|Any , info: Any , cb?: Function) : string
  setBlob(id: string , type: string , value: string|Any , info: Any) : void
 }
 export = exports
}
declare module "docs/mixin_docs_persist" {
 const exports: {
  $checkInit(doc: Doc) : void
  $clearDocData(docId: string) : void
  $finishLoad(doc: any , res: any) : void
  $isPending(id: any) : any
  $persistDoc() : void
  getPersistentRef(id: string) : string
  loadDocs(idToLoadSync: string , cb: Function , ignoreFail: any) : void
  persist() : void
  registerFactory(type: string , constructor: Function) : void
  stashDoc(docId: string) : void
  toJSON() : Any
 }
 export = exports
}
declare module "docs/mixin_docs_save" {
 const exports: {
  $updateStatus(id: string) : void
  delete(path: any , fs: any) : void
  dirty(id: any) : void
  filterWithin(path: string , fs: Any) : Array<unknown>
  onRefresh(doc: Doc , err: any , res: string , callback: boolean , ignoreDirty: boolean , confirm: boolean) : void
  rename(path: string , newpath: string , fs?: Any) : void
  saveAs(id: string , newpath: string , fileServer?: FS|undefined , callback?: any) : void
  saveDocs(id: string , callback?: any , force?: any) : void
  setEncoding(id: any , encoding: any) : void
 }
 export = exports
}
declare module "docs/mixin_docs_tabs" {
 const exports: {
  addTabAnnotation(id: string , anno: Any) : void
  autoMode(path: string) : string
  canDiscard(id: string) : boolean
  closeDoc(docId: string , keepUndos: any) : void
  closeSession(session: EditSession) : void
  getAnnotations(id: string) : void
  getInfo(id: string) : string
  initialize() : void
  openDoc(name: string|falsy , content/*:string|Doc*/: Doc|string , path?:/*:string?*/ string|falsy , opts?: Any|undefined) : string
  removeTabAnnotation(id: string , anno: Any) : void
 }
 export = exports
}
declare module "editor/ace_helpers" {
 const exports: {
  setupEditor(el: HTMLDivElement) : Editor
 }
 export = exports
}
declare module "editor/editor_fonts" {
 const exports: Any
 export = exports
}
declare module "editor/editor_settings" {
 const exports: {
  $defaults: {
   annotateScrollbar: boolean
   enableArgumentHints: boolean
   enableAutocompletion: boolean
   enableBasicAutocompletion: boolean
   enableCompletionTooltips: boolean
   enableEmmet: boolean
   enableIntelligentAutocompletion: boolean
   enableLiveAutocompletion: boolean
   enableSnippets: boolean
   enableTabCompletion: boolean
   hideNonLatinChars: boolean
   keyboardHandler: string
   readOnly: boolean
   theme: string
   useNativeContextMenu: boolean
   wrap: boolean
  }
  $options: {
   [optionName:string]: Any
  }
  add(edit: Editor) : void
  addOption(key: string , option: Any|undefined , type: any) : void
  editor: Editor
  editors: Array<Editor>
  getOption(key: string) : any
  getOptions() : any
  options: Any
  session: EditSession
  setOption(key: string , val: string) : void
  setOptions(optList: any) : void
  validator: {
   [optionName:string]:Schema}
 }
 export = exports
}
declare module "editor/editors" {
 const exports: {
  $allEditors: Array<unknown>
  $getEditor(session?: any) : any
  Editors: typeof exports
  closeEditor(edit: Editor) : void
  createEditor(container: HTMLDivElement|DocumentFragment , orphan?: boolean|undefined) : Editor
  findEditor(session: any) : any
  forEach() : any
  getSettingsEditor() : Any
  onEach(e: Function , ctx?: any) : void
  setEditor(e: Editor) : void
  setSession(doc: Doc) : void
 }
 export = exports
}
declare module "editor/host_editor" {
 const exports: {
  $getActiveEditor() : Editor
  focusEditor(editor: Editor) : Any|undefined
 }
 export = exports
}
declare module "ext/config/action_context" {
 const exports: Any
 export = exports
}
declare module "ext/config/config_doc" {
 import {Doc} from 'docs/document'
 interface ConfigDoc extends Doc {
  factory: string
  getSavePath() : undefined
  refresh(callback: any , ignoreDirty: boolean , confirm: any) : boolean
  save() : void
 }
 const exports: {
  ConfigDoc : {
   super():any
   prototype: ConfigDoc
   new():ConfigDoc
  }
 }
 export = exports
}
declare module "ext/config/configs" {
 const exports: {
  $getConfig(path: any) : any
  $parseRules(conf: any , ns: any) : any
  Configs: typeof exports
  _debug: boolean
  apply() : any
  commit() : boolean
  diff(base: any , config: any) : Any
  removeConfig(name: string , inFront: number) : void
  save() : any
  setConfig() : any
  toJSON() : Any
  update(value: Any , path: string , mask: Any) : boolean
  withErrorHandler(err: any , func: any) : any
  withSource(source: any , func: any , _a: any , _b: any) : any
  withUpdateHandler(handler: Function , func: Function , _a: string , _b?: string|undefined) : void
 }
 export = exports
}
declare module "ext/config/context" {
 const exports: {
  COMPARE<U>(op: any , variable: U , curr: any , cache: any , name: any) : U
  Context: typeof exports
  GLOB(glob: any , path: any , cache: any , name: any) : boolean
  _debug: boolean
  getContext(name: string) : string
  refresh(name: string , value: any , force: any) : void
  registerContext(name: string , type: string , compare: string , info: any) : void
  registerRules(all: any , ns: any) : void
  setContext(name: string , value: string|boolean|undefined , force: any) : void
  withContext(name: string , value: string|undefined , func: Function) : any
 }
 export = exports
}
declare module "ext/config/context_parser" {
 const exports: {
  parseKey(key: any , errHandler: any) : Any
 }
 export = exports
}
declare module "ext/config/editor_contexts" {
 const exports: Any
 export = exports
}
declare module "ext/config/key_binding" {
 const exports: {
  addUserBindings(editor: Editor) : void
 }
 export = exports
}
declare module "ext/config/linter_options" {
 const exports: Any
 export = exports
}
declare module "ext/config/settings_menu" {
 const exports: {
  SettingsPanel: import('core/ace_loader!ext/options').OptionPanel
 }
 export = exports
}
declare module "ext/dev/dts_gen" {}
declare module "ext/dev/runtime_info" {}
declare module "ext/diff/diff" {
 const exports: {
  addToDiffMenu(id: any , caption: any , getRes: any , isAvailable: any) : void
  createDiffView(type: any , data: any , useInlineDiff: any) : any
  registerDiffFactory(name: any , onLoadDiff: any) : void
 }
 export = exports
}
declare module "ext/docs/checkpoints" {
 const exports: Any
 export = exports
}
declare module "ext/docs/partial_undo" {
 const exports: Any
 export = exports
}
declare module "ext/docs/setup_doc_exts" {
 const exports: Any
 export = exports
}
declare module "ext/editor/all_tools" {
 const exports: {
  allTools: {
   [id:string]: string | {
    icon: string
    caption?: string
    onhold?: string
   }
  }
 }
 export = exports
}
declare module "ext/editor/enhanced_clipboard" {
 const exports: {
  clipboard: {
   _clip: Array<string>
   onchange() : void
  }
 }
 export = exports
}
declare module "ext/editor/mods" {
 const exports: {
  Mods: {
   clear() : void
   dispatch(key: any) : void
   handleClipboard(action: any) : any
   press(key: string) : void
   setChangeListener(cb: Function) : void
   setClipboard(e: Any) : void
   setEditor(e: Editor) : void
   startHold(key: string , touchID: string) : void
   stopHold(touchID: string) : void
  }
 }
 export = exports
}
declare module "ext/editor/multi_clipboard" {
 export class MultiClipboard{
  
 }
 const exports: {
  MultiClipboard: typeof MultiClipboard
 }
 export default exports
}
declare module "ext/editor/repeat_detector" {
 class RepeatDetector {} //TODO
 const exports: {
  RepeatDetector : typeof RepeatDetector
 }
 export = exports
}
declare module "ext/editor/scroll_lock" {
 class ScrollLock {} //TODO
 const exports: {
  ScrollLock : typeof ScrollLock
 }
 export = exports
}
declare module "ext/editor/setup_character_bar" {
 const exports: Any
 export = exports
}
declare module "ext/editor/setup_emmet" {
 const exports: Any
 export = exports
}
declare module "ext/editor/swipe_detector" {
 class SwipeDetector {} //TODO
 const exports: {
  SwipeDetector : typeof SwipeDetector
 }
 export = exports
}
declare module "ext/editor/textedit" {
 const exports: {
  TextEdit: {
   commit() : void
   cursorPos: number
   data: number
   delete(numChars: any) : void
   from(textArea: HTMLInputElement) : Any
   indent: string
   insert(text: string) : void
   moveAnchor(offset: any) : void
   moveCursor(offset: any , collapse: any) : void
   selection() : string
   selectionEnd: number
   selectionStart: number
   target: any
   wordBefore() : string
  }
 }
 export = exports
}
declare module "ext/file_utils/glob" {
 const exports: Any
 export = exports
}
declare module "ext/file_utils/walk" {
 const exports: {
  copyFolder(path: any , newpath: any , server: FS|undefined , newServer: FS|undefined , cb: Function , onConflict: any , onEach: any) : void
  moveFolder(path: any , newpath: any , server: FS|undefined , newServer: FS|undefined , cb: Function , onConflict: any , onEach: any , isCopy: any) : Function
  walk(opts: any) : any
 }
 export = exports
}
declare module "ext/fileview/file_browser" {
 export class FileBrowser {
  attachEvents(): void
  blur(): any
  childFilePath(name: string, check: any, ctx: any): string
  clipboard: {
   data: any
   mode: number
  }
  closeInlineDialog(): void
  createHeader(): void
  createTreeView(): void
  createView(stub: $Element): void
  destroy(): void
  emitter: EventsEmitter
  enterSelectMode(filename: any): void
  exitSelectMode(): any
  fileDropdown: string
  filename(e: string, notChild: boolean, ctx: Any): string
  filter(text: any): any
  folderDropdown: string
  getCurrentElement(): any
  getElement(name: any): any
  getItemTop(index: number, init: any, cumul: any): number
  getOrCreateView(i: any): any
  getScrollingElements(): $Element | undefined
  goto(path: any, cb: Function, isFolder: any): boolean
  handleScroll(scrollElement: any, ev: any): boolean
  headerDropdown: string
  itemHeight: number
  mark(filename: any): void
  menuItems: Any
  moveTo(newEl: any, oldEl: any): void
  newFile(name: string, callback: any): void
  onBackPressed(): Function
  onCtxMenuClick(id: string, filename: string, el: HTMLAnchorElement, item: Any, anchor: HTMLLIElement): void
  onDismissCtxMenu(): void
  onFileClicked(): Function
  onFolderClicked(): Function
  onNewOption(types: Array <unknown> , id: string, caption: Any, func: any): void
  openFile(filename: string, forceNew: any, cb: Function): void
  openFolder(file: any): void
  overflows: Any
  pageSize: number
  parentDir(): any
  projectDropdown: string
  reload(highlightNewFiles: boolean | undefined, callback: Function | undefined, rootDir: any): void
  removeEvents(): void
  rename(former: string, b: string): void
  renderView(i: number, view: $Element): void
  scrollItemIntoView(filename: any, updatePage: any): void
  selectAll(): void
  setRootDir(dir: string): void
  setShowFileInfo(val: boolean): void
  shiftTo(newEl: any, oldEl: any): void
  showCtxMenu(menu: string, el: HTMLLIElement): void
  showFileInfo: boolean
  showInlineDialog(el: any, callback: Function, status: string, val: string): void
  toggleMark(name: any): void
  toggleTreeView(): void
  tree: any
  unmark(filename: any): any
  updateBottomElements(): any
  updateHeader(): void
  updateHierarchy(names: Array <string> , highlightNewFiles?: boolean ): void
  updateTopElements(): void
  updateVisibleItems(force: boolean): void
  validateNewFileName(name: string, ctx: Any): void
  viewTemplate: string
 }
 export class NestedBrowser extends FileBrowser {
  constructor(id: any, rootDir: any, fileServer: FS | undefined, noReload: any)
  cancelFind(): void
  childFolderDropdown: string
  clearNestedViews(): void
  createHeader(): void
  enterSelectMode(): void
  expandAll(callback: any, depth: any, eachCallback: any, accumulator: any): any
  expandFolder(name: any, callback: any): void
  fileDropdown: string
  filter(): void
  findFile(text: any, timeout: any, callback: any): any
  foldAll(): void
  foldFolder(name: string): void
  folderDropdown: string
  foldersToIgnore: Array <string>
  getParent(): NestedBrowser
  getScreenTop(): any
  getScrollingElements(): $Element | undefined
  goto(path: string, cb: Function, isFolder: any): boolean
  handleScroll(element: any, e: any): boolean
  headerDropdown: string
  isTree: boolean
  iterate(callback: any, maxDepth: any, eachCallback: any, delveDepth: any): any
  menuItems: {
   [type: string]: Action
  }
  nestedFileDropdown: string
  nestedFolderDropdown: string
  onCtxMenuClick(id: string, filename: string, el: HTMLAnchorElement): void
  openFolder(name: string): void
  removeEvents(): void
  scrollItemIntoView(filename: any, updatePage: any): string
  setParent(browser: NestedBrowser): void
  stopFind(): void
  superNestedBrowser: FileBrowser
  updateBottomElements(): void
  updateTopElements(): void
  updateVisibleItems(full: boolean): void
 }
 export class ProjectView extends NestedBrowser {
  constructor(id: $Element, rootDir: string, fileServer?: Any )
  close(): void
  filename(name: string): string
  folderDropdown: string
  goto(path: any, cb: Function, arg2: any): any
  isHierarchy: boolean
  menuItems: Any
  newFile(): any
  reload(highlightNewFiles: any, callback: any): void
  rename(name: string, newname: string): void
  superProjectView: NestedBrowser
 }

 const exports: {
  FileBrowser : typeof FileBrowser
  NestedBrowser : typeof NestedBrowser
  ProjectView : typeof ProjectView
 }
 export default exports
}
declare module "ext/fileview/file_icons" {
 const exports: {
  DefaultIconProvider: {
   renderEl(el: $Element , icon: string , name: string , cls: any) : $Element
   renderHTML(icon: any , name: any , cls: any) : any
  }
  FileIconClasses: {
   [extension:string]: string
  }
  FileIcons: {
   renderEl(el: $Element , icon: string , name: string , cls: any) : $Element
   renderHTML(icon: any , name: any , cls: any) : any
  }
  registerIconProvider(name: any , provider: any) : void
 }
 export = exports
}
declare module "ext/fileview/fileviews" {
 import {TabHost} from 'ui/tab_host';
 import {FileBrowser} from 'ext/fileview/file_browser'
 const exports: {
  Fileviews: EventsEmitter & {
   Impl: typeof FileBrowser
   addBrowser(filebrowser: FileBrowser) : void
   beforeClose(event: any , func: any) : void
   createBrowser(id: string , fileServer: FS|FS , rootDir: any , icon: any) : FileBrowser
   deleteBrowser(browserID: string) : any
   exitSaveMode() : void
   freezeEvent(event: Any) : Any
   getOpenDocs(id: any) : Array<unknown>
   inSaveMode() : void
   initBrowser(params: Any) : FileBrowser
   initialize(container: Any , tabs: TabHost) : void
   loadBrowsers() : void
   newBrowser() : void
   pickFile(info: string , end: Function , allowNew?: falsy) : void
   saveAs(doc: string) : void
   unfreezeEvent<T>(event: T) : T
  }
 }
 export = exports
}
declare module "ext/fileview/recycler_browser" {
 import {FileBrowser,NestedBrowser} from 'ext/fileview/file_browser'
 interface FileItemHolder extends $Element {} //TODO
 export class RFileBrowser extends FileBrowser {
  static super(): any
  constructor(id: string, rootDir: any, fileServer: FS | FS, noReload: any, renderer: any)
  closeInlineDialog(): void
  createFileItem(): $Element
  createTreeView(): void
  createView(): void
  destroy(): void
  getElement(name: string): FileItemHolder
  getOrCreateView(i: number): FileItemHolder
  onBeforeRender(): void
  pageSize: number
  renderView(index: number, view: FileItemHolder): void
  showInlineDialog(el: any, m: Function, status: any, p: string): void
  superClass: FileBrowser & {
   /*<recursive>*/ }
  updateVisibleItems(force: boolean): void
 }

 export class RNestedBrowser extends RFileBrowser {
  static super() : any
  constructor(id: $Element , rootDir: string , fileServer: Any|undefined , noReload/*,renderer = null*/: boolean)
  cancelFind() : void
  childFolderDropdown: string
  clearNestedBrowsers() : void
  clearNestedViews() : void
  createHeader() : void
  enterSelectMode() : void
  expandAll(callback: any , depth: any , eachCallback: any , accumulator: any) : any
  expandFolder(name: string , callback: any) : void
  fileDropdown: string
  filter() : void
  findFile(text: any , timeout: any , callback: any) : any
  foldAll() : void
  foldFolder(name: string) : void
  folderDropdown: string
  foldersToIgnore: Array<unknown>
  getOffsetTop() : number
  getParent() : RNestedBrowser
  getScreenTop() : any
  getScrollingElements() : $Element|undefined
  goto(path: string , cb: Function , isFolder: any) : boolean
  handleScroll(element: any , e: any) : boolean
  headerDropdown: string
  isTree: boolean
  iterate(callback: any , maxDepth: any , eachCallback: any , delveDepth: any) : any
  menuItems: Any
  mixinNestedBrowser: NestedBrowser & {/*<recursive>*/}
  nestedFileDropdown: string
  nestedFolderDropdown: string
  onChildRender() : void
  onCtxMenuClick(id: string , filename: string , el: HTMLAnchorElement) : void
  openFolder(name: string) : void
  removeEvents() : void
  scrollItemIntoView(filename: string , updatePage: boolean) : void
  setParent(browser: RNestedBrowser) : void
  stopFind() : void
  superNestedBrowser: RFileBrowser & {/*<recursive>*/}
  updateBottomElements() : void
  updateTopElements() : void
  updateVisibleItems(full: boolean) : void
 }
 export class RProjectView extends RNestedBrowser {
  static super() : any
  constructor()
  close() : void
  filename(name: string) : string
  folderDropdown: string
  goto(path: any , cb: Function , arg2: any) : any
  isHierarchy: boolean
  menuItems: Any
  newFile() : any
  rename(name: string , newname: string) : void
  superProjectView: RNestedBrowser & {/*<recursive>*/}
 }
 const exports: {
  RFileBrowser : typeof RFileBrowser
  RNestedBrowser : RNestedBrowser
  RProjectView : typeof RProjectView
 }
 export default exports
}
declare module "ext/fileview/setup_fileview" {
 const exports: Any
 export = exports
}
declare module "ext/fix_missing_colons" {
 const exports: Any
 export = exports
}
declare module "ext/format/fmt_js_beautify" {
 const exports: Any
 export = exports
}
declare module "ext/format/fmt_prettier" {
 const exports: Any
 export = exports
}
declare module "ext/format/format" {
 const exports: {
  FormatCommands: Array<Action>
 }
 export = exports
}
declare module "ext/format/formatters" {
 import {Provider} from 'core/registry';
 const exports: {
  getFormatter(mode: string , path: any) : Function
  getFormatterByName(name: any) : any
  registerFormatter(provider: Provider) : Provider
  registerFormatter(provider: string , modes: Array<string> , handle: Function , aliases?: any) : Provider
 }
 export = exports
}
declare module "ext/fs/browser_fs" {
 const exports: Any
 export = exports
}
declare module "ext/fs/find_fs" {
 class FindFileServer {} //TODO
 const exports: {
  FindFileServer : typeof FindFileServer
 }
 export = exports
}
declare module "ext/fs/httpfs" {
 const exports: Any
 export = exports
}
declare module "ext/git/git" {
 const exports: Any
 export = exports
}
declare module "ext/git/git_utils" {
 const exports: {
  GitUtils: typeof exports
  createProgress(status: any) : Any
  failure(e: TypeError) : void
  handleError(e: TypeError , data: any) : void
  padStart(str: any , len: any , pad: any) : void
  readFile(name: any , prov: any , cb: Function) : void
  removeFile(name: any , prov: any , cb: Function) : void
  success() : void
  testPlain(str: any) : boolean
  testUrl(str: any) : boolean
  writeFile(name: any , content: any , prov: any , cb: Function) : void
 }
 export = exports
}
declare module "ext/git/merge3highlight" {
 const exports: {
  highlightMerge3() : void
 }
 export = exports
}
declare module "ext/index" {
 const exports: Any
 export = exports
}
declare module "ext/json_ext" {
 import mod = require('core/parser');
 const exports: {
  JSONExt: mod.RuleParser & {
   parse(str: string) : any
   addComments(str: string , getInfo: Function) : string
   stringify(obj: Any , transformer: any) : string
  }
  JSONParser : typeof mod.RuleParser
 }
 export = exports
}
declare module "ext/language/base_client" {
 import mod = require('core/events_emitter');
 export type BaseClientData = {
  doc?: EditSession
  changed?: boolean|null
  changes?: Array<Ace.Delta>|null
  version?: string
 }
 export abstract class BaseClient extends mod.EventsEmitter implements Ace.Completer{
  static PRIORITY_HIGH: number
  static PRIORITY_MEDIUM: number
  static PRIORITY_LOW: number
  static super(): any
  constructor(options: Any, iconClass: any)
  abstract sendDoc(): void
  abstract releaseDoc(): void
  abstract normalizeName(name: string): string
  restart?: () => void
  name: string
  docs: Record<string,BaseClientData>
  requestAnnotations?: () => void
  requestReferences?: () => void
  genArgHintHtml?: (tip: any, pos: any) => any
  genInfoHtml?: (tip: any) => string
  getCompletions: (editor: Editor, session: EditSession, pos?: Ace.Point, prefix?: string, callback?: Ace.CompleterCallback) => void
  requestArgHints?: (editor: any, cursor: any, cb: Function) => any
  requestDefinition?: (editor: any, cb: Function) => any
  requestType?: (editor: any, pos: any, cb: Function) => any
  $onDestroySession(session: EditSession): void
  addDoc(name: string, session_or_text: string|EditSession, preferSession: any): Any
  cachedArgHints: any
  closeDoc(name: string): void
  currentJumpList: any
  destroy(): void
  executeRename(editor: Editor, newName: string, cache: Any): void
  findRefs(editor: any, cb: Function): any
  functionHintTrigger: string
  getCallPos(editor: Editor, pos: Any, cb: Function): void
  getChanges(doc: Any): void
  goto(editor: Editor, ref: Any, cb: Function, keepTips: any, ignoreClosed: any): void
  hasDoc(name_or_session: string|EditSession): void
  invalidateDoc(doc: Any): void
  jumpBack(editor: any, cb: Function): void
  jumpToDef(editor: Editor, cb: Function): void
  lastJumpPosition: any
  loadFiles(data: any, cb: Function): any
  markPos(editor: Editor): void
  maxSize: number
  openFiles(data: any, cb: Function): any
  refreshDoc(editor: any, full: any): any
  removeDoc(name: any): any
  rename(editor: Editor): void
  resetDocs(editor: any): void
  setupForRename(editor: any, newName: any, cb: Function, cache: any): any
  showType(editor: Editor, pos: any, calledFromCursorActivity: boolean): void
  trackChange(change: Any, session: EditSession): void
  updateAnnotations(editor: Editor, cb: Function): void
  updateArgHints(editor: Editor): void
 }
 export const ClientUtils: {
  applyChanges(ts: any , changes: any , defaultText: any , cb: Function) : any
  cmpPos(a: any , b: any) : any
  docValue(ts: BaseClient , data: Any) : string
  getCallPos(editor: any , pos: any) : boolean|null|Any
  getCurrentToken(editor: any) : any
  getDoc(ts: BaseClient , session: EditSession , name: any) : Any
  getExtension(mode: string) : string
  setSelection(ts: any , editor: any , pos: any) : void
  somethingIsSelected(editor: any) : any
 }
 const exports: {
  BaseClient : typeof BaseClient
  ClientUtils: typeof ClientUtils
 }
 export default exports
}
declare module "ext/language/base_provider" {
 import {Provider} from 'core/registry';
 export class BaseProvider extends Provider {
  static super(): any
  static addDocumentsOnOpen(provider: any): void
  static setupLifeCycle(provider: any): void
  static keepDocumentsOnClose(provider: any, yes: any): any
  constructor(name: string | undefined, modes?: Array <unknown> )
  addDocToInstance(doc: Doc): void
  attachToEditor(editor: Editor, instance: BaseClient, cb: Function): void
  destroy(instance: any): any
  embeddable: boolean
  hasAnnotations: boolean
  hasArgHints: boolean
  hasCompletions: boolean
  hasDefinitions: boolean
  hasFormatting: boolean
  hasKeyWords: boolean
  hasReferences: boolean
  hasRename: boolean
  hasStrings: boolean
  hasText: boolean
  hasTypeInformation: boolean
  init(): void
  isEnabled(): boolean
  isSupport: boolean
  name: string
  options: Any
  priority: number
 }
 const exports: {
  BaseProvider : typeof BaseProvider
 }
 export default exports
}
declare module "ext/language/file_loader" {
 export class FileLoader {} //TODO
 const exports: {
  FileLoader : typeof FileLoader
 }
 export default exports
}
declare module "ext/language/lsp/lsp_provider" {
 const exports: {
  getLanguageServer(config: any) : any
 }
 export = exports
}
declare module "ext/language/lsp_ui" {
 export class UI {
  closeAllTips(except: any): void
  closeArgHints(ts: BaseClient): void
  cls: string
  createToken(part: Any, extraClass: any): string
  iconClass(type: string): string
  iconCls: string
  makeTooltip(x: any, y: any, content: string, editor: Editor, closeOnCursorActivity: boolean, fadeOutDuration: any,
   onClose: any): HTMLDivElement
  moveTooltip(tip: HTMLDivElement, x: any, y: any, editor: Editor, max_width: any, max_height: any): void
  referenceDialog(): any
  renameDialog(ts: BaseClient, editor: Editor, data: Any): void
  showArgHints(ts: BaseClient, editor: Editor, argpos: number): void
  showError(editor: any, msg: any, noPopup: any): any
  showInfo(editor: any, msg: any): void
  tempTooltip(editor: any, content: any, timeout: any): any
 }

 const exports: {
  LspUI : typeof UI
 }
 export default exports
}
declare module "ext/language/misc/basic_completion" {
 const exports: {
  addCompleter(completer: Any) : void
  removeCompleter(completer: Any) : void
 }
 export = exports
}
declare module "ext/language/misc/colors" {
 const exports: {
  colorCompleter: {
   filterPrefix: string
   filterSuffixes: {
    [prefix:string]: string
   }
   getCompletions(editor: Editor , session: EditSession , pos: Any , prefix: string , callback: Function) : void
   getDocTooltip(item: Any) : void
   insertMatch(editor: any , data: any) : void
   name: string
   registered: boolean
  }
 }
 export = exports
}
declare module "ext/language/misc/filename" {
 const exports: {
  fileNameCompleter: {
   getCompletions(editor: any , session: any , pos: any , prefix: any , callback: any) : any
   insertMatch(editor: any , data: any) : void
   name: string
   registered: boolean
  }
 }
 export = exports
}
declare module "ext/language/misc/snippets" {
 const exports: Any
 export = exports
}
declare module "ext/language/server_host" {
 import {FileLoader} from 'ext/language/file_loader';
 
 const exports: {
  ServerHost: {
   $fileLoader: FileLoader
   $neverAllowLoad: any
   $stopLoad(): void
   $watchMemory(): void
   getFileName(s: EditSession): string
   loadAutocompleteFiles(cb: Function | undefined, lsp? : BaseClient): void
   normalize(path: string): string
   readFile(name: string, cb: Function): void
   registerProvider(provider: BaseProvider): void
   switchToDoc(name: any, pos: any, end: any, autoLoad: any, cb: Function, server? : FS): any
   toggleProvider(provider: BaseProvider, modes: Array < unknown > , value: string | boolean): void
   unregisterProvider(provider: BaseProvider): void
  }
 }
 export = exports
}
declare module "ext/language/services/commands" {
 const exports: {
  registerProvider(provider: BaseProvider , modes: any , handle: any , aliases: any) : BaseProvider
  unregisterProvider(provider: BaseProvider) : void
 }
 export = exports
}
declare module "ext/language/services/completion" {
 const exports: {
  getCompletionProviderByName: any
  registerCompletionProvider(provider: BaseProvider , modes: any , handle: any , aliases: any) : BaseProvider
  unregisterCompletionProvider(provider: BaseProvider) : void
 }
 export = exports
}
declare module "ext/language/services/hover" {
 const exports: {
  registerHoverProvider(provider: BaseProvider , modes: any , handle: any , aliases: any) : BaseProvider
  unregisterHoverProvider(provider: BaseProvider) : void
 }
 export = exports
}
declare module "ext/language/services/lint" {
 const exports: {
  registerLintProvider(provider: BaseProvider) : void
  unregisterLintProvider(provider: BaseProvider) : void
 }
 export = exports
}
declare module "ext/language/setup_services" {
 const exports: Any
 export = exports
}
declare module "ext/language/tags/find_props" {
 const exports: {
  inferProps(propCache: any , name: any , path: any , session: any , paths: any , timeout: any) : Any
 }
 export = exports
}
declare module "ext/language/tags/scope" {
 class DocStream {
  getCurrentIndex() : any
  indexToPosition(i: any) : any
  next() : any
 }
 class LineStream {
  static from<T>(stream: T) : LineStream|T
  getCurrentIndex() : any
  indexToPosition(i: any) : Any
  next() : any
 }
 class TextStream {
  getCurrentIndex() : any
  next() : any
 }
 const exports: {
  DocStream : typeof DocStream
  LineStream : typeof LineStream
  ScopeSolvers: {
   c_cpp(stream: any) : Array<unknown>
   dart(stream: any) : Array<unknown>
   java(stream: any) : Array<unknown>
   javascript(stream: any) : Array<unknown>
   jsx(stream: any) : Array<unknown>
   kotlin(stream: any) : Array<unknown>
   php(stream: any) : Array<unknown>
   python(rawStream: any) : Array<unknown>
   typescript(stream: any) : Array<unknown>
  }
  TextStream : typeof TextStream
  scopeIterator(scopes: any) : boolean|Any
 }
 export = exports
}
declare module "ext/language/tags/setup_tags" {
 import {Tags} from 'ext/language/tags/tags_completer'
 const exports: {
  TagCompleter: Tags & {
   files: Any
   isOptionEnabled(_option: string , mode: string , path?: string|undefined) : boolean
   isOptionMatching(_option: any , value: any , path: any) : any
   lastUpdate: number
   modes: Array<unknown>
   propCache: Any
   tagFilePattern: {
    test() : any
   }
  }
 }
 export = exports
}
declare module "ext/language/tags/tags_completer" {
  import {BaseClient} from 'ext/language/base_client'
  export class Tags extends BaseClient {
  static super(): any
  constructor()
  releaseDoc(): void
  sendDoc(): void
  genArgHintHtml: (tip: any, pos: any)=> any
  genInfoHtml: (tip: any)=> string
  getCompletions: (editor: Editor, session: EditSession, pos: Any, prefix: string, callback: Function)=> void
  normalizeName: (name: string)=> string
  requestArgHints: (editor: any, cursor: any, cb: Function)=> any
  requestDefinition: (editor: any, cb: Function)=> any
  requestType: (editor: any, pos: any, cb: Function)=> any
  addDoc(name: any, session: any): any
  addDocToInstance(doc: Doc): void
  attachToEditor(editor: Editor, instance: BaseClient, cb: Function): void
  clear(): void
  destroy(): void
  docChanged(): void
  embeddable: boolean
  exportTags(fs: any, folder: any, cb: Function): any
  flatWalk(tagFile: any, each: any, opts: any): void
  getDocTooltip(item: Any): void
  getQueryArgs(editor: any, cursor: any, name: any): null | Any
  hasAnnotations: boolean
  hasArgHints: boolean
  hasCompletions: boolean
  hasDefinitions: boolean
  hasFormatting: boolean
  hasKeyWords: boolean
  hasReferences: boolean
  hasRename: boolean
  hasStrings: boolean
  hasText: boolean
  hasTypeInformation: boolean
  importTags(res: any): any
  init(editor: Editor, cb: Function): void
  isEnabled(): boolean
  isOptionEnabled(): void
  isOptionMatching(): void
  isSupport: boolean
  loadParsedTags(filename: any, header: any, tags: any): any
  loadTags(filename: string, doc_or_string /*Doc or string*/ : Doc, noOverwrite /*false*/ : any, mode: any): void
  name: string
  options: Any
  priority: number
  query(name: any, pos: any, file: any, fnOnly: any, allowGlobal: any): Array <unknown> | null
  refreshDoc(): void
  rename: any
  tagFilePattern: RegExp
  trackChange(): void
  triggerRegex: RegExp
  updateTags(path: string): void
 }
 export const ImportResolvers: Any
 export const TagFinders: {
  text(res: string) : Array<unknown>|undefined
 }
 export const exports: {
  ImportResolvers: typeof ImportResolvers,
  TagFinders: typeof TagFinders
  TagsCompleter : typeof Tags
 }
 export default exports
}
declare module "ext/language/tern/tern_provider" {
 const exports: {
  ternCompletionProvider: BaseProvider & {
   embeddable: boolean
   hasArgHints: boolean
   hasKeyWords: boolean
   hasRename: boolean
   init(editor: any , callback: any) : any
   isEnabled() : boolean
   options: {
    defs: Array<string|Any>
    fileFilter<T>(val: T , name: any , session: any) : T
    getFileName(s: EditSession) : string
    plugins: {
     doc_comment: boolean
    }
    readFile(name: string , cb: Function) : void
    startedCb() : void
    switchToDoc(name: any , pos: any , end: any , autoLoad: any , cb: Function , server?: FS|undefined) : any
    timeout: number
    useWorker: boolean
   }
   priority: number
   triggerRegex: RegExp
  }
 }
 export = exports
}
declare module "ext/language/ts/ts_provider" {
 const exports: {
  tsCompletionProvider: BaseProvider & {
   hasAnnotations: boolean
   hasArgHints: boolean
   hasRename: boolean
   init(editor: Editor , cb: Function) : void
   isEnabled() : string
   priority: number
   triggerRegex: RegExp
  }
 }
 export = exports
}
declare module "ext/parse_schema" {
 const exports: Any
 export = exports
}
declare module "ext/preview_file" {
 const exports: Any
 export = exports
}
declare module "ext/print_schema" {
 const exports: {
  printSchema(schema: any , indent: any) : any
 }
 export = exports
}
declare module "ext/run/markdown" {
 const exports: Any
 export = exports
}
declare module "ext/run/node" {
 const exports: Any
 export = exports
}
declare module "ext/run/run" {
 class Preview {
  reload(frame: any , path: any , live: any) : void
  run(path: any , doc: any) : any
 }
 const exports: {
  Execute: {
   BasePreview : typeof Preview
   preview(path: any , reloader: any) : any
   registerRunMode(id: string , mode: Any) : void
   runCode(editor: any , options: any) : any
  }
 }
 export = exports
}
declare module "ext/run/run_button" {
 const exports: Any
 export = exports
}
declare module "ext/run/svg" {
 const exports: Any
 export = exports
}
declare module "ext/search/search_box" {
 const exports: Any
 export = exports
}
declare module "ext/search/search_tab" {
 class SearchTab {} //TODO
 const exports: {
  SearchTab : typeof SearchTab
 }
 export = exports
}
declare module "ext/stop_signal" {
 export class StopSignal {
  clear() : void
  control(func: Function , onAborted?: boolean|Function) : Function
  stop(cause?: any) : boolean
  subscribe(func: Function) : void
  unsubscribe(func: any) : void
  data?: any
 }
 const exports: {
  StopSignal : typeof StopSignal
 }
 export default exports
}
declare module "ext/storage/db_storage" {
 class DBStorage<T=Any> {
  constructor(id:string)
  $setItem(id: string , data: T) : void
  _persist() : void
  beginBatch() : void
  createItem(id: string , data: T) : void
  endBatch() : any
  getItem(id: string) : T
  handleChange(old: any , newVal: any) : void
  hasItem(id: string) : boolean
  load(onLoadItem: Function , onLostItem: any , onNoItem: any , onFinish: Function) : void
  removeItem(id: string) : void
  setItem(id: any , data: T , create?: boolean|falsy) : void
  withinBatch(func: any , ctx: any) : void
 }
 const exports: {
  DBStorage : typeof DBStorage
 }
 export = exports
}
declare module "ext/switch_to_doc" {
 const exports: {
  switchToDoc(name: any , pos: any , end: any , autoLoad: any , cb: Function , server?: FS|undefined) : any
 }
 export = exports
}
declare module "ext/ui/import_theme" {
 const exports: Any
 export = exports
}
declare module "ext/ui/nametags" {
 const exports: {
  NameTags: {
   createTag(editor: Editor) : void
   hide() : void
   removeTag(editor: Editor) : void
   show() : void
  }
 }
 export = exports
}
declare module "ext/ui/split_editors" {
 const exports: {
  SplitEditors: {
   close(edit: any) : any
   commands: Array<unknown>
   create(edit: any , direction: any) : any
   isSplit(editor: any) : any
   showDoc(doc: any) : boolean
  }
 }
 export = exports
}
declare module "ext/ui/swipe_n_drag" {
 const exports: Any
 export = exports
}
declare module "ext/ui/tab_window" {
 const exports: {
  closeTabWindow(id: any , isOpen: any) : void
  getHostEditor(editor: Editor) : Editor
  getTabWindow(id: string , name: any , info: any , onClose: Function , insert: boolean , host: Any) : Any
  hideClickable() : void
  showClickable() : void
 }
 export = exports
}
declare module "ext/ui_thread" {
 const exports: {
  UiThread: {
   awaitIdle() : any
   blockIdle() : void
   idlePromise: any
   isIdle: boolean
   toggle() : void
  }
 }
 export = exports
}
declare module "setup/index" {
 const exports: Any
 export = exports
}
declare module "setup/setup_actionbar" {
 import {LinearLayout} from 'ui/linear_layout'
 const exports: {
  actionBar: LinearLayout & {
   height: number
   layout_height: number
   layout_weight: any
   shorter: boolean
  }
 }
 export = exports
}
declare module "setup/setup_docs" {
 const exports: Any
 export = exports
}
declare module "setup/setup_editors" {
 const exports: {
  editorView: View & {
   height: number
   layout_height: any
   layout_weight: number
  }
  getActiveDoc() : Doc
  getEditor(session?: EditSession|undefined) : Editor
  getMainEditor(session: any) : any
 }
 export = exports
}
declare module "setup/setup_error_message" {
 const exports: Any
 export = exports
}
declare module "setup/setup_immersive" {
 const exports: Any
 export = exports
}
declare module "setup/setup_key_listener" {
 const exports: {
  addListener(target: any , capture: any) : void
  getEvent() : InputEvent|falsy
 }
 export = exports
}
declare module "setup/setup_menu_items" {
 const exports: Any
 export = exports
}
declare module "setup/setup_root" {
 import {LinearLayout} from 'ui/linear_layout'
 const exports: {
  rootView: LinearLayout & {
   onRender() : any
  }
 }
 export = exports
}
declare module "setup/setup_sideview" {
 import {TabPager} from 'ui/tab_pager'
 import {TabHost} from 'ui/tab_host'
 const exports: {
  SideView: import('ui/sidenav').Sidenav
  SideViewTabs: TabHost & {
   afterClick(id: any) : void
   pager: TabPager & {
    ID_ATTR: string
    createItem(id: string) : string
   }
  }
 }
 export = exports
}
declare module "setup/setup_state" {
 const exports: {
  State: {
   addListener(func: Function , preCheck: Function) : void
   attach() : void
   back() : void
   detach() : void
   ensure(tag: string , handled?: boolean|undefined) : void
   exit(now: any) : Function
   forward() : void
   is(tag: string) : boolean
   isValidState(state: string) : boolean|undefined
   onChange(newState: string , oldState: string , dir?: boolean|undefined) : boolean|undefined
   removeListener(func: any) : any
  }
 }
 export = exports
}
declare module "setup/setup_statusbar" {
 const exports: {
  statusBarView: View & {
   height: number
   layout_height: number
   layout_weight: any
  }
 }
 export = exports
}
declare module "setup/setup_tab_host" {
 import {TabHost} from 'ui/tab_host'
 const exports: {
  DocsTab: TabHost & {
   afterClick(id: string , previousTab?: string|undefined) : boolean
   onClose(id: string) : boolean
  }
  closeTab(id: string) : boolean
  setTab(tab: any) : void
 }
 export = exports
}
declare module "setup/setup_window_vars" {
 const exports: Any
 export = exports
}
declare module "themes/theme_gen" {
 const exports: {
  ThemeGen: {
   light(percent: any , color: any) : any
   parse(color: any) : Array<unknown>
   tint(percent: any , color: any) : any
   vs(json: any , id: any) : any
  }
 }
 export = exports
}
declare module "themes/themes" {
 const exports: {
  watchTheme(els: any , addClass: any) : void
 }
 export = exports
}
declare module "ui/auto_closeables" {
 const exports: {
  AutoCloseables: {
   add(id: string , closeable: Closeable) : void
   close(id: string) : void
   onCloseEnd() : void
   onOpenEnd() : void
   remove(id: string) : void
  }
 }
 export = exports
}
declare module "ui/dropdown" {
 export interface UpdateCallback{
  // The dropdown being shown. Must not be modified directly.
  (self: DropdownData,
  // Accepts two arguments, a property to update and its new value.
  update: (prop:string,value:Any|null)=>void 
  )
 }
 export type DropdownData = ({
  "!update":Array<UpdateCallback>|null
  [prop:string]:{
   ["!update"]?: UpdateCallback,
   caption?: string,
   isHeader?: boolean,
   sortIndex?: number,
   className?: string,
   icon?: string,
   subIcon?: string,
   subTree?: DropdownData,
   rebase?: boolean // true if to anchor this item's subtree to the parent anchor
   hasChild?: boolean,
   // set by this dropdown when an item with hasChild is clicked
   anchor?: HTMLElement
   onclick?: (ev: Event, id: string, item: HTMLElement)=>void
   [prop:string]: any
  } | Array<UpdateCallback>|null})
 export class Dropdown implements Closeable{
  static create(self: Dropdown, keepFocus: any, align: any, vAlign: any): void
  static count: number
  static defaultLabel(label: any): Any
  static assign(dest: any, src: any): void
  static minIconPercent: number
  static createElement(items: Any, id: string): HTMLUListElement
  static clipWindow(box: any, itemSize: any, size: any, vertical: any): Array <number|undefined>
  static defaultAlignment: string
  static positionElement(element: HTMLUListElement, anchor: HTMLElement, inside?: HTMLElement, align?: string,
   allowBeside?: boolean, vertAlign?: any): void
  static openSelect(ev: any, select: any): void
  constructor(e?:any,align?:string,f?:any)
  id: string
  close(): void
  hide(): void
  show(el?:$Element):void
  createTrigger(el: $Element):void
  onOverlayClick(ev:MouseEvent):void
  update(data?: DropdownData):void
  ondismiss(e?: MouseEvent): void
  onclick(e:MouseEvent, id:string, span: $Element, data: DropdownData[keyof DropdownData], anchor: HTMLElement)
  setData(data?:DropdownData|null,invalidateRe?:RegExp): void
 }

 const exports: {
  Dropdown : typeof Dropdown
 }
 export default exports
}
declare module "ui/focus_manager" {
 export const FOCUS_RESIZE_WINDOW: number
 export const FocusManager: {
   activeElement: any
   debug() : void
   focusIfKeyboard(el: HTMLElement , allowHardwareKbd?: any , force?: any) : void
   FOCUS_RESIZE_WINDOW: typeof FOCUS_RESIZE_WINDOW
   hintChangeFocus() : void
   hintNoChangeFocus() : void
   isFocusable(el: any) : boolean
   keyboardVisible: boolean
   onModalOpen() : void
   release(el: any) : void
   trap(el: $Element , eagerly?: boolean|undefined) : void
   visit(newfocus: HTMLInputElement , forceFocus?: any) : Function
  }
 const exports: {
  FocusManager: typeof FocusManager
 }
 export default exports
}
declare module "ui/itemlist" {
 import {EventsEmitter}from 'core/events_emitter'
 class ItemList extends EventsEmitter {
  static super() : any
  constructor(id: any , items: any , container: any)
  blur() : void
  containerClass: string
  createElement() : any
  createItem(index: any) : any
  emptyText: string
  getCurrentElement(root: HTMLElement) : HTMLElement
  getElementAtIndex(index: any) : any
  getElements(root: any) : any
  getHtml(index: any) : any
  getItem(index: any) : any
  getLength() : any
  getNext(current: any , root: any) : any
  getPrev(current: any , root: any) : any
  getRoot() : any
  headerText: string
  itemClass: string
  listClass: string
  moveTo(newEl: any , oldEl: any) : void
  onenter(e: any) : void
  render() : void
  select(index: any) : void
  selectAll() : void
  shiftTo(newEl: any , oldEl: any) : void
 }
 const exports: {
  ItemList : typeof ItemList
 }
 export = exports
}
declare module "ui/linear_layout" {
 import {View} from 'ui/view'
 export class LinearLayout extends View {
  static VERTICAL: number
  static HORIZONTAL: number
  static super(): any
  constructor(root: $Element | undefined, size: number | undefined, orientation: string | number)
  addView(view: View, index: number, size? : number, weight? : number): View
  onContentChanged(): void
  onRender(): void
  render(): void
 }

 const exports: {
  LinearLayout : typeof LinearLayout
 }
 export default exports
}
declare module "ui/navigation" {
 const exports: {
  Navigation: {
   addRoot(el: $Element, onClose?:Function|undefined,trap?:boolean) : void
   attach() : void
   detach() : void
   pop() : void
   removeRoot(el:$Element) : void
  }
 }
 export = exports
}
declare module "ui/notify" {
 const exports: {
  Notify: {
   ask(text: string , yes: Function , no: any) : void
   dialog(caption: any , onchang: any , getValue: any , ondismis: any , complete: any) : Any
   direct(info: string , ondismiss: any) : Function
   error(error: string , duration?: number) : void
   info(text: string , duration?: number) : void
   inform(error: any , duration?: number) : void
   modal(opts: Any , ondismiss?: Function) : HTMLDivElement
   notify(text: any , duration?: number) : any
   pick(name: any , items: any , onItemSelected?: Function|undefined , ondismiss?: Function|undefined) : any
   prompt(text: any , func: any , defText: any , value_completer: any) : any
   warn(text: string , duration?: number) : void
  }
 }
 export = exports
}
declare module "ui/recycler" {
 interface Viewport {
   height: number
   y: number
 }
 interface ViewHolder{
  compute(viewport: Viewport) : number
  detach() : void
  hide() : void
  invalidate(start: any) : void
  render(viewport: Viewport , index: number , insertBefore?: HTMLElement , restack?: boolean) : void
  show() : void
 }
 class FastCache {
  clone(el: HTMLElement) : FastCache
  pop(container: any , before: any) : $Element
  push(el: $Element) : void
  sync() : void
 }
 class NestedRenderer extends RecyclerRenderer implements ViewHolder {
  constructor(view: $Element , renderer: RecyclerRenderer , root: HTMLElement)
  compute(viewport/*, index*/: Viewport) : number
  detach() : void
  getViewport(viewport: Viewport) : Viewport
  hide() : void
  /* Must not be used */
  render(viewport: Viewport, index: number , insertBefore?: HTMLElement , restack?: boolean) : void
  render(viewport: never) : never
  schedule() : void
  show() : void
  superRenderer: typeof RecyclerRenderer
  superViewHolder: typeof RecyclerViewHolder
 }
 class RecyclerRenderer {
  DEFAULT_VIEWPORT: Viewport
  INFINITE_VIEWPORT: Viewport
  compute(viewport?: Viewport) : number
  createViewport(y: any , height: any , margin: any) : Viewport
  detach() : void
  getViewport(viewport: any) : Viewport
  invalidate(start: any) : void
  register(index: number , view: ViewHolder) : void
  render(viewport?: Viewport) : void
  schedule() : void
  scrollTo(scrollTop: number , topMargin: any) : void
  unregister(view: ViewHolder) : void
 }
 class RecyclerViewCache {
  clone(el: HTMLElement) : RecyclerViewCache
  pop(container: HTMLElement|undefined , before: any) : $Element
  push(el: $Element) : void
 }
 class RecyclerViewHolder {
  bindView() : void
  compute() : number
  detach() : void
  hide() : void
  invalidate() : void
  render(viewport: Any , index: number , insertBefore?: HTMLDivElement|undefined , restack?: boolean|undefined) : void
  show() : void
 }
 const exports: {
  FastCache : typeof FastCache
  NestedRenderer : typeof NestedRenderer
  RecyclerRenderer : typeof RecyclerRenderer
  RecyclerViewCache : typeof RecyclerViewCache
  RecyclerViewHolder : typeof RecyclerViewHolder
  ScrollSaver: {
   getScroll(els: $Element) : number
   getScrollingElements(el: any) : any
   restoreScroll(els: any , scrolls: any) : number
   saveScroll(els: $Element) : Array<unknown>
  }
  ViewportVisualizer: {
   create(root: any , renderer: any) : any
   update() : void
  }
  renderStats: {
   append: number
   detach: number
   insert: number
  }
 }
 export = exports
}
declare module "ui/sidenav" {
 export interface SidenavOptions{
  dragTargetWidth: number
  draggable: boolean
  edge: string
  inDuration: number
  minWidthPush: number
  onCloseEnd: any
  onCloseStart: any
  onOpenEnd: any
  onOpenStart: any
  outDuration: number
}
 export class Sidenav {
  static getInstance(el: any) : any
  static defaults: SidenavOptions
  
  static _sidenavs: Array<Sidenav>
  _animateIn(wasOpen: any) : void
  _animateOut(wasClosed: boolean) : void
  _animateOverlayIn() : void
  _animateOverlayOut() : void
  _animateSidenavIn(wasOpen: any) : void
  _animateSidenavOut(wasClosed: boolean) : void
  _createOverlay() : void
  _dragMoveUpdate(e: TouchEvent) : void
  _onDragClose(e: TouchEvent) : void
  _onDragOpen(e: TouchEvent) : void
  _onReleaseDragClose() : void
  _onReleaseDragOpen(e: TouchEvent) : void
  _onStartDragClose(e: TouchEvent) : void
  _onStartDragOpen(e: TouchEvent) : void
  _onWindowResize() : void
  _removeClasses() : void
  _removeEventHandlers() : void
  _setupClasses() : void
  _setupEventHandlers() : void
  _startDrag(e: TouchEvent) : void
  _updateType() : boolean
  close(ev?: MouseEvent|undefined) : void
  open() : void
  toggle(el: MouseEvent) : void
  isOpen: boolean
  options: SidenavOptions
  el: HTMLElement
  $el: $Element
  id: string
  isOverlay: boolean
 }

 const exports: {
  Sidenav : typeof Sidenav
 }
 export default exports;
}
declare module "ui/soft_keyboard_navigation" {
 const exports: {
  KeyListener: Any
  attach(el: HTMLElement , keyHandler: Any) : void
  detach(keyHandler: any) : void
  dispatchEvent(self: any , ev: any , hash: any) : any
 }
 export = exports
}
declare module "ui/split_manager" {
 const exports: {
  SplitManager: {
   add(container: $Element , direction?: "vertical"|"horizontal" , gutterSize?: number) : HTMLDivElement
   hasSplit(child: any) : boolean
   remove(child: $Element) : boolean
  }
 }
 export = exports
}
declare module "ui/state_manager" {
 class StateManager {} //TODO
 const exports: {
  StateManager : typeof StateManager
 }
 export = exports
}
declare module "ui/tab_host" {
 import {TabRenderer} from 'ui/tab_renderer'
 export class TabHost {
  constructor(id:string)
  $deleteTab(index: number, id: string): void
  $usePersistedActive: boolean
  active: string
  tabs: Array<String>
  //should be set manually
  afterClick(id: string , previousTab?: string|undefined) : boolean
  //should be set manually
  onClose(id: string) : boolean
  addAnnotation(id: string, annotation: Any): void
  addRenderer(renderer: TabRenderer): void
  addTab(id: string, name: string | undefined, annotations: any, info: any): void
  afterClick(): void
  getAnnotations(id: string): void
  getInfo(id: any): any
  getName(id: any): any
  getOwner(id: string): Any | undefined
  hasTab(id: string): boolean
  indexOf(id: string): number
  insertTab(dindex: number | undefined, id: string, name: string | undefined, annotations: any, info: any): void
  isSavedTab(id: string): boolean
  moveTab(index: number, id: string, relative: any): boolean
  numTabs(): number
  recreate(): void
  registerPopulator(char: string, pop: Any): void
  removeAnnotation(id: string, annotation: Any): void
  removeTab(id: string): void
  replaceTab(id: string, name: string, annotations: any): void
  setActive(id: string, click: boolean, scroll?: boolean ): void
  setAnnotations(id: string, annotations: Array <unknown>): void
  setName(id: string, name: string): void
  tempAnnotations: Any
  tempData: {
   [id: string]: {
    annotations: any
    info: any
    name: string
   }
  }
  updateActive(): void
 }
 const exports: {
  TabHost : typeof TabHost
 }
 export default exports
}
declare module "ui/tab_pager" {
 import {TabRenderer} from 'ui/tab_renderer'
 export class TabPager extends TabRenderer {
   static super() : any
   constructor(el: $Element)
   TAB_ITEM_CLS: string
   scrollIntoView() : void
   setActive(el: $Element) : void
  }
  
 const exports: {
  TabPager : typeof TabPager
 }
 export default exports
}
declare module "ui/tab_renderer" {
 import {TabHost} from 'ui/tab_host'
 export class TabRenderer {
  $el: any
  $setSingleTabs(val: boolean): void
  CLOSE_BTN_CLS: string
  ID_ATTR: string
  TAB_ITEM_CLS: string
  createAnnotationItem(anno: Array <unknown>): string
  createItem(id: string, name: string): string
  getOnClickListener(host: TabHost, scroll?: boolean ): Function
  getTabEl(id: string): $Element
  getTabId(el: $Element): string
  scrollIntoView(el: $Element): void
  setActive(el: $Element): void
  setAnnotations(id: string, el?: string ): void
  setFadeCloseIcon(): void
 }
 const exports: {
  TabRenderer : typeof TabRenderer
 }
 export default exports
}
declare module "ui/textarea" {
 class InvisibleTextArea extends HTMLTextAreaElement{
  constructor(el:HTMLElement)
 } //TODO
 const exports: {
  InvisibleTextArea : typeof InvisibleTextArea
 }
 export = exports
}
declare module "ui/ui_utils" {
 const exports: {
  createSearch(input: string , button: string , onsearch: Function) : void
  styleCheckbox(el: $Element) : void
  styleClip(el: $Element) : void
  tabulate(data: any) : string
 }
 export = exports
}
declare module "ui/view" {
 export class View {
  _dismount(): boolean
  $el: $Element
  constructor(el: $Element)
  _mount(parent: Any, beforeEl?: HTMLDivElement ): boolean
  addView(view: View, index: number): void
  createElement(): void
  destroy(): void
  hide(): void
  onContentChanged(): void
  onDestroy(): void
  onDismount(): void
  onMount(): void
  remove(): void
  removeView(view: any): void
  render(): void
  show(): void
  toggle(): void
 }

 const exports: {
  View : typeof View
 }
 export default exports
}


///Bonus Definitions
declare module "core/ace_loader" {
 const exports: {
  load(path: string , require: Function , onload: Function , config: Any) : void
 }
 export = exports
}
declare module "core/ace_loader!ext/emmet" {
 class AceEmmetEditor {
  $updateTabstops<T>(value: T) : T
  createSelection(start: any , end: any) : void
  getCaretPos() : any
  getContent() : any
  getCurrentLine() : any
  getCurrentLineRange() : Any
  getFilePath() : string
  getProfileName() : string
  getSelection() : any
  getSelectionRange() : Any
  getSyntax() : string
  prompt(title: any) : any
  replaceContent(value: any , start: any , end: any , noIndent: any) : void
  setCaretPos(index: any) : void
  setupContext(editor: any) : void
 }
 const exports: {
  AceEmmetEditor : typeof AceEmmetEditor
  commands: HashHandler
  isAvailable(editor: any , command: any) : boolean
  isSupportedMode() : void
  load() : any
  runEmmetCommand(editor: any) : boolean
  setCore(e: any) : void
  updateCommands(editor: Editor , enabled: any) : void
 }
 export = exports
}
declare module "core/ace_loader!ext/language_tools" {
 const exports: {
  addCompleter(completer: Any) : void
  keyWordCompleter: {
   getCompletions(editor: Editor , session: EditSession , pos: Any , prefix: string , callback: Function) : void
  }
  removeCompleter(completer: Any) : void
  setCompleters(val: any) : void
  snippetCompleter: {
   getCompletions(editor: any , session: any , pos: any , prefix: any , callback: any) : void
   getDocTooltip(item: any) : void
  }
  textCompleter: {
   DISTANCE_CLOSE: number
   MAX_SCORE: number
   getCompletions(editor: Editor , session: EditSession , pos: Any , prefix: string , callback: Function) : void
  }
 }
 export = exports
}
declare module "core/ace_loader!ext/menu_tools/get_editor_keyboard_shortcuts" {
 const exports: {
  getCommandsByKey(editor: Editor) : Any
  getCommandsByName(editor: Editor , validate: boolean) : Any
  normalizeKey(k: any) : any
 }
 export = exports
}
declare module "core/ace_loader!ext/options" {
 export class OptionPanel {
  _dispatchEvent(eventName: any, e: any): any
  _emit(eventName: any, e: any): any
  _signal(eventName: string, e: Any): void
  add(config: Any): void
  addEventListener < U > (eventName: any, callback: U, capturing: any): U
  getOption(option: Any): any
  off(eventName: any, callback: any): any
  on<U>(eventName: any, callback: U, capturing: any): U
  once(eventName: any, callback: any): Promise <unknown>
  optionGroups: {
   [title: string]: {
    [optionName: string]: {
     items? : Array <unknown>
     label: string
     path: string
     position? : number
     defaultValue? : number
     defaults? : Array <unknown> 
     type?: string
     getValue(): any
     onchange(val: any): void
    }
   }
  }
  removeAllListeners(eventName: any): void
  removeDefaultHandler(eventName: any, callback: any): any
  removeEventListener(eventName: any, callback: any): any
  removeListener(eventName: any, callback: any): any
  render(): boolean
  renderOption(key: any, option: any): Array <unknown>
  renderOptionControl(key: string, option: Any): Array <unknown>
  renderOptionGroup(group: Any, name: string): Array <unknown>
  renderOptionGroupHeader(name: string): Array <unknown>
  etDefaultHandler(eventName: any, callback: any): void
  setEditor(editor: Any): void
  setOption(option: Any, value: string): void
  unfoldGroup(): Function
}
 const exports: {
  OptionPanel : typeof OptionPanel
 }
 export default exports
}
declare module "core/ace_loader!ext/searchbox" {
 export class SearchBox {
  $closeSearchBarKb: HashHandler
  $init(): void
  $initElements(sb: HTMLDivElement): void
  $searchBarKb: HashHandler
  $syncOptions(preventScroll: boolean): void
  ALIGN_ABOVE: string
  ALIGN_BELOW: string
  ALIGN_NONE: any
  align: string
  alignContainer(top?: string ): void
  find(skipCurrent: boolean, backwards: boolean, preventScroll: boolean): void
  findAll(): void
  findNext(): void
  findPrev(): void
  hide(): void
  highlight(re: any): void
  isFocused(): any
  replace(): void
  replaceAll(): void
  replaceAndFindNext(): void
  setEditor(editor: Editor): void
  setSearchRange(range: any): void
  setSession(e: any): void
  show(value: string, isReplace: any): void
  updateCounter(): void
 }
 export const Search: (editor: Editor , isReplace: any) => void
 const exports: {
  Search: typeof Search
  SearchBox : typeof SearchBox
 }
 export default exports
}
declare module "core/ace_loader!ext/statusbar" {
 class StatusBar {
  setEditor(edit: Editor) : void
  updateStatus(editor: Editor) : void
 }
 const exports: {
  StatusBar : typeof StatusBar
 }
 export = exports
}
declare module "core/ace_loader!ext/whitespace" {
 const exports: {
  $detectIndentation(lines: Array<string> , fallback: any) : Any|undefined
  $parseArg<T>(arg: T) : T|Any
  $parseStringArg(text: string) : Any
  commands: Array<Any>
  convertIndentation(session: any , ch: any , len: any) : void
  detectIndentation(session: EditSession) : Any
  trimTrailingSpace(session: any , options: any) : any
 }
 export = exports
}
declare module "core/ace_loader!keyboard/hash_handler" {
 class HashHandler {
  _addCommandToBinding(keyId: string , command: Any|string , position: any) : void
  _buildKeyHash(command: Any) : void
  _unbindKey(keyId: any , command: any) : void
  addCommand(command: Any) : void
  addCommands(commands?: Any|undefined) : void
  bindKey(key: Any|string , command: Any|string , position: any) : void
  bindKeys(keyList: Any) : void
  findKeyCommand(hashId: number , keyString: string) : void
  getStatusText(editor: Editor , data: Any) : string
  handleKeyboard(data: Any , hashId: number , keyString: string , keyCode: number) : Any
  parseKeys(keys: string) : Any
  removeCommand(command: Any , keepCommand: any) : void
  removeCommands(commands: any) : void
 }
 const exports: {
  HashHandler : typeof HashHandler
  MultiHashHandler(config: any , platform: any) : void
 }
 export = exports
}
declare module "core/ace_loader!token_iterator" {
 class TokenIterator {
  getCurrentToken() : Any
  getCurrentTokenColumn() : number
  getCurrentTokenPosition() : Any
  getCurrentTokenRange() : Range
  getCurrentTokenRow() : number
  stepBackward() : Any
  stepForward() : void
 }
 const exports: {
  TokenIterator : typeof TokenIterator
 }
 export = exports
}
declare module "libs/js/base64" {}
declare module "libs/js/diff_match_patch.js" {}
declare module "libs/js/eruda.min.js" {
 const exports: Any
 export = exports
}
declare module "libs/js/materialize" {}
declare module "libs/js/require-css/css" {
 const exports: {
  load(cssId: string , req: Function , load: Function , config: Any) : void
  normalize(name: string , normalize: Function) : string
  pluginBuilder: string
 }
 export = exports
}
declare module "libs/js/require-css/css!ext/fileview/file_browser" {}
declare module "libs/js/require-css/css!ext/language/lsp_ui" {}
declare module "libs/js/require-css/css!ext/search/search_tab" {}
declare module "libs/js/require-css/css!index" {}
declare module "libs/js/require-css/css!libs/css/coding-fonts" {}
declare module "libs/js/require-css/css!libs/css/materialize-colors" {}
declare module "libs/js/require-css/css!libs/css/materialize-grace" {}
declare module "libs/js/require-css/css!themes/base" {}
declare module "libs/js/splits.min.js" {
 const Split : (e: Array<unknown> , i: Any) => Any
 export = /*Unexpected token [)|41]. Expected } at position 1943
:->=Math.round(t/z[here])*z),t<=n.*/Split
}
declare module "libs/js/text/text" {
 const exports: {
  createXhr() : XMLHttpRequest
  finishLoad(name: string , strip: boolean , content: string , onLoad: Function) : void
  get(url: string , callback: Function , errback: Function , headers: any) : void
  jsEscape(content: any) : any
  load(name: string , req: Function , onLoad: Function , config: Any) : void
  parseName(name: string) : Any
  strip(content: any) : string
  useXhr(url: string , protocol: string , hostname: string , port: any) : boolean
  version: string
  write(pluginName: any , moduleName: any , write: any , config: any) : any
  writeFile(pluginName: any , moduleName: any , req: any , write: any , config: any) : any
  xdRegExp: RegExp
 }
 export = exports
}
declare module "libs/js/text/text!ext/search/search_tab.html" {
 const exports: string
 export = exports
}
declare module "libs/js/text/text!setup/setup_sideview.html" {
 const exports: string
 export = exports
}
declare module "ext/ui/libs/drag-tabs" {
 import {EventsEmitter}from 'core/events_emitter'
 class DragList extends DragTabs {
  static super() : any
  constructor()
  _moveTab(event: any) : any
 }
 class DragTabs extends EventsEmitter {
  static super() : any
  constructor(el: any , options: Any)
  _bind(eventName: string , fn: Function , parent?: HTMLUListElement|undefined) : void
  _init() : void
  _moveTab(event: any) : any
  _onDragend(event: any) : void
  _onDragstart(event: any) : any
  _onDrop(event: any) : void
  _setDraggable() : void
  _unbind(eventName: any , fn: any , parent: any) : void
  getActiveTabNode() : any
  getAllTabNodes() : $Element
  getTabsContainerNode() : void
  update() : void
 }
 const exports: {
  DragList : typeof DragList
  DragTabs : typeof DragTabs
 }
 export = exports
}
declare module "ext/file_utils/libs/micromatch" {
 export default function(e: any , t: any , n: any) : any
}
declare module "ext/fs/libs/lightning-fs.min.js" {}
declare module "ext/ui/libs/hammer.min" {}
declare module "ext/ui/libs/mobile-drag" {
 const exports: {
  polyfill(override: Any) : boolean
 }
 export = exports
}
declare module "ext/ui/libs/scroll-behaviour" {
 const exports: {
  scrollBehaviourDragImageTranslateOverride(event: TouchEvent , currentCoordinates: Any , hoveredElement: any , translateDragImageFn: Function) : void
 }
 export = exports
}