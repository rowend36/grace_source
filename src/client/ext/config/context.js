define(function (require, exports, module) {
  var Utils = require('grace/core/utils').Utils;
  var Schema = require('grace/core/schema').Schema;
  var Config = require('grace/core/config').Config;
  var FileUtils = require('grace/core/file_utils').FileUtils;
  var Notify = require('grace/ui/notify').Notify;
  var appEvents = require('grace/core/app_events').AppEvents;
  var Configs = require('./configs').Configs;
  var debug = console;
  var Context = exports;
  Context._debug = false;
  //Executes the contexts generated by
  //('./configs').Configs
  Config.registerAll(
    {
      rules: [],
    },
    '_triggers',
  );
  Config.on('_triggers', function (ev) {
    if (ev.config === 'rules') return updateUserRules(ev.value());
  });

  var TYPES = {};
  Config.registerInfo(
    {
      '!root': 'no-user-config',
      rules: {
        //Removed validation since only 5 possible types:
        //numbers,strings,booleans, null and undefined
        type: 'array<object>',
        contexts: TYPES,
      },
    },
    '_triggers',
  );

  var nodes = [],
    defaultRules = [], //stores defaultRules and childNodes
    userRules = [];
  var ctxs = {};
  function toggleNode(e) {
    Configs.setConfig(e._id, e._true ? e.options : null, true);
  }
  /**
   * Updates are triggered by
   * 1. Loading/Adding/Removing rules.
   * 2. Setting a context.
   * 3. Modifying a configuration.
   * (Also by changing project because of globs)
   */
  function updateNode(e, cause) {
    var _true = Context.COMPARE(
      e.rule.op,
      e.rule.val,
      cause,
      e._cache,
      e.rule.ctx,
    );
    // must be here not in merge rules because of not operator
    if (e._true === undefined) e._true = false;
    if (e._true !== _true) {
      e._true = _true;
      if (Context._debug)
        debug.log(
          '[',
          e.options ? e._id : '.',
          '] ',
          _printRule(false, e.rule),
          ' => ',
          e._true,
        );

      if (e.options) toggleNode(e);
      else return updateNode(e._parent, e._id);
      return true;
    }
  }

  //Setup
  function addProp(e, name, value) {
    Object.defineProperty(e, name, {
      value: value,
      writable: true,
      enumerable: false,
    });
  }
  var _id = 0; //number properties are sorted in v8
  function setupNode(e) {
    //Use unenumerable properties to not break Configs
    e._id || addProp(e, '_id', 'r' + _id++);
    addProp(e, '_true');
    //Stores nodes,counters for binary ops, regex for globs etc.
    addProp(e, '_cache');
    addProp(e, '_parent');
    if (e.rule.op == 'or' || e.rule.op == 'and') {
      e._cache = {
        _guard: e.rule.op === 'and' ? e.rule.val.length : 0,
        nodes: [],
      };
      e._true = false; //assume all rules are false
      e.rule.val.forEach(setupChild.bind(null, e));
    } else if (e.rule.op == 'not') {
      setupChild(e, e.rule.val);
    } else if (e.rule.op == '=~') e._cache = {};
    return e;
  }
  function setupChild(parent, rule) {
    var e = setupNode({
      rule: rule,
      options: undefined,
    });
    e._parent = parent;
    if (parent.rule.op === 'not') parent._cache = e;
    else parent._cache.nodes.push(e);
    defaultRules.push(e);
  }
  function destroyNode(e) {
    if (e.rule.op == 'or' || e.rule.op == 'and')
      e._cache.nodes.forEach(destroyNode);
    else if (e.rule.op == 'not') destroyNode(e._cache);
    if (e._parent) defaultRules.splice(defaultRules.indexOf(e), 1);
    else Configs.removeConfig(e._id, true);
    e._parent = e._cache = e._true = undefined;
  }
  function mergeRules(d, u, end, hasRemoved) {
    nodes.length = 0;
    nodes.push.apply(nodes, defaultRules);
    nodes.push.apply(nodes, userRules);
    for (var j = u; j < userRules.length; j++) {
      //restack to ensure execution order
      Configs.removeConfig(userRules[j]._id, true);
      toggleNode(userRules[j]);
    }
    for (var i = d, c = 0, e; (e = nodes[i]), i < end; i++) {
      if (e._true !== undefined) continue;
      var init =
        e.rule.op !== 'not'
          ? e.rule.ctx.indexOf('.') < 0
            ? ctxs[e.rule.ctx]
            : Configs.$getConfig(e.rule.ctx)
          : e._cache;
      if (updateNode(e, init)) c++;
    }
    if (c > 0 || hasRemoved) Configs.commit();
  }
  function updateUserRules(newRules) {
    userRules.filter(Utils.notIn(newRules)).forEach(destroyNode);
    var d = defaultRules.length;
    newRules.filter(Utils.notIn(userRules)).forEach(setupNode);
    var o = userRules.length;
    var n = newRules.length;
    for (var u = 0, m = Math.max(o, n); u < m; u++) {
      if (newRules[u] !== userRules[u]) break;
    }
    if (Context._debug) {
      debug.log(
        [
          u < o ? 'Removed rules ---\n-' : '',
          userRules
            .slice(u)
            .map(e => '[' + e._id + ']' + _printRule(false, e.rule))
            .join('\n-'),
          u < n ? '\nAdded rules +++\n+' : '',
          newRules
            .slice(u)
            .map(e => '[' + e._id + ']' + _printRule(false, e.rule))
            .join('\n+'),
        ].join(''),
      );
    }
    userRules = newRules;
    //d - index of first change in default rules
    //u - index of first change in user rules
    //u<o means some nodes were removed forcing committing.
    mergeRules(d, u, n + defaultRules.length, u < o);
  }

  Context.registerRules = function (all, ns) {
    var d = defaultRules.length;
    Configs.$parseRules(all, ns).forEach(function (e) {
      setupNode(e);
      toggleNode(e);
      defaultRules.push(e);
    });
    //default rules restack the entire userRules
    mergeRules(d, 0, defaultRules.length, false);
  };

  //Changing context
  Context.refresh = function (name, value, force) {
    var c = 0;
    nodes.forEach(function (e) {
      if (e.rule.ctx === name && updateNode(e, value)) c++;
    });
    if (c > 0 || force) Configs.withErrorHandler(Notify.inform, Configs.commit);
  };
  Context.getContext = function (name) {
    return name.indexOf('.') < 0 ? ctxs[name] : Configs.$getConfig(name);
  };
  Context.registerContext = function (name, type, compare, info) {
    if (typeof compare === 'string') {
      info = compare;
      compare = false;
    }
    TYPES[name] = type || Schema.IsPlain;
    if (compare) operators[name] = compare;
    if (info) Config.registerInfo(info, '_triggers.rules.' + name);
  };
  Context.setContext = function (name, value, force) {
    if (ctxs[name] !== value) ctxs[name] = value;
    else if (!force) return;
    Context.refresh(name, value, force);
  };
  Context.withContext = function (name, value, func) {
    var m = ctxs[name];
    try {
      var conf = Config.allConfigs;
      Configs.withUpdateHandler(
        function (update) {
          for (var i in update) {
            if (i !== '_triggers')
              conf[i] = Object.assign({}, conf[i], update[i]);
            else updateUserRules(update[i].rules);
          }
        },
        Context.setContext,
        name,
        value,
      );
      return func(conf);
    } finally {
      if (ctxs[name] === value) Context.setContext(name, m);
    }
  };

  var _trigger = Config.trigger;
  /** @override*/
  Config.trigger = function (namespace, ev) {
    var result = _trigger.call(Config, namespace, ev);
    Context.refresh(namespace + '.' + ev.config, ev.value());
    return result;
  };
  //TODO: Possible also override register and registerAll
  //Comparators/Operators
  var operators = {
    not: function (rule, id, node) {
      return !node._true;
    },
    or: function (rules, id, cache) {
      if (id) {
        cache[id] = !cache[id];
        if (cache[id]) cache._guard++;
        else cache._guard--;
      }
      return cache._guard !== 0;
    },
    and: function (rules, id, cache) {
      if (id) {
        cache[id] = !cache[id];
        if (cache[id]) cache._guard--;
        else cache._guard++;
      }
      return cache._guard === 0;
    },
  };
  Context.GLOB = function (glob, path, cache, name) {
    if (path === glob) return true;
    if (!glob || typeof path !== 'string') return false;
    var _globToRe = FileUtils.globToRegex;
    if (!_globToRe) {
      require(['grace/ext/file_utils/glob'], function () {
        if (Context.getContext(name) === path) {
          Context.setContext(name, path, true);
        }
      });
      return false;
    }
    if (!cache.glob) cache.glob = _globToRe(glob);
    return (
      cache.glob.test(path) ||
      cache.glob.test(FileUtils.filename(path)) ||
      cache.glob.test(FileUtils.relative(FileUtils.getProject().rootDir, path))
    );
  };
  Context.COMPARE = function (op, rvalue, curr, cache, name) {
    switch (op) {
      case '==':
        return rvalue === curr;
      case '!=':
        return rvalue != curr;
      case '!!':
        return !!curr;
      case '>':
        return curr > rvalue;
      case '>=':
        return curr >= rvalue;
      case '<':
        return curr < rvalue;
      case '<=':
        return curr <= rvalue;
      case '=~':
        return Context.GLOB(rvalue, curr, cache, name);
      default:
        return operators[op](rvalue, curr, cache);
    }
  };
  function _checkGlobs() {
    var c = 0;
    nodes.forEach(function (e) {
      if (e.rule.op === '=~' && updateNode(e, Context.getContext(e.rule.ctx)))
        c++;
    });
    if (c > 0) Configs.commit();
  }

  function _printRule(hideValues, rule) {
    if (rule.ctx) {
      var value =
        hideValues === true ? '' : '<' + Context.getContext(rule.ctx) + '>';
      if (rule.op !== '!!') {
        var t = rule.val;
        if (typeof t === 'string' && /[^\w]/.test(t))
          t = "'" + t.replace(/\'/g, "\\'") + "'";
        return '(' + rule.ctx + value + ' ' + rule.op + ' ' + t + ')';
      } else return rule.ctx + value;
    } else if (rule.op === 'not')
      return '!' + _printRule(hideValues, rule.val) + '';
    else {
      var names = {and: '&&', or: '||'};
      return (
        '(' +
        rule.val
          .map(_printRule.bind(null, hideValues))
          .join(' ' + (hideValues ? names[rule.op] : rule.op) + ' ') +
        ')'
      );
    }
  }
  function _printConfig(config, ctx, arr) {
    return config._triggers.rules.some(function (node) {
      if (arr.indexOf(node.rule) > -1) return true;
      arr.push(node.rule);
      if (node.options) {
        var key =
          '[' + _printRule(true, node.rule).replace(/^\(|\)$/g, '') + ']';
        while (ctx[key]) {
          key = key + ' ';
        }
        var m = node.options;
        if (m._triggers || m.__n$x$t) m = Object.assign({}, m);
        ctx[key] = m;
        if (m.__n$x$t) {
          m[''] = m.__n$x$t;
          delete m.__n$x$t;
        }
        if (m._triggers) {
          if (m._triggers.rules) {
            var ret = _printConfig(m, m, arr);
            delete m._triggers;
            return ret;
          }
        }
      }
    });
  }
  Context.toJSON = function (ctx) {
    //forgive the one-liner
    return _printConfig(Config.allConfigs, ctx || (ctx = {}), []), ctx;
  };
  appEvents.on('changeProject', _checkGlobs);
  appEvents.on('fullyLoaded', function () {
    var loadedRules = Config.allConfigs._triggers.rules;
    if (loadedRules !== userRules) updateUserRules(loadedRules);
  });
  Config.on('files', function (ev) {
    if (ev.config === 'dotStar') _checkGlobs();
  });
  exports.Context = Context;
});